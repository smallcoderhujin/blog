I"á°<h2 id="èƒŒæ™¯">èƒŒæ™¯</h2>

<p>è¿›ç¨‹è§„åˆ™ã€æ–‡ä»¶è§„åˆ™ã€ç½‘ç»œè§„åˆ™ã€dlpã€waféƒ½æ˜¯åœ¨ç›‘æ§ç»„ä¸‹çš„åŠŸèƒ½ã€‚æœ¬æ¬¡æˆ‘ä»¬é€šè¿‡æºç çš„æ–¹å¼æ¥æ·±å…¥äº†è§£æ–‡ä»¶è§„åˆ™æ˜¯å¦‚ä½•å®ç°çš„ã€‚
æ–‡ä»¶è§„åˆ™æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰å…³æ³¨çš„æ–‡ä»¶ã€ç›®å½•ï¼Œè®¾ç½®è§„åˆ™çš„å­¦ä¹ æˆ–è€…ä¿æŠ¤æ¨¡å¼ï¼Œç›¸åº”çš„å¦‚æœå®¹å™¨è®¿é—®åˆ°äº†æŒ‡å®šçš„æ–‡ä»¶ï¼Œä¸”æ–‡ä»¶è§„åˆ™è®¾ç½®ä¿æŠ¤æ¨¡å¼ï¼Œåˆ™å¯¹æ–‡ä»¶çš„å†™ä¼šäº§ç”Ÿå‘Šè­¦ã€‚</p>

<h2 id="æ¶æ„å›¾">æ¶æ„å›¾</h2>

<p><img src="/blog/img/neuvector_file0.png" alt="neuvector file" /></p>

<p>æˆ‘ä»¬ä»å‡ ä¸ªç»´åº¦æ¥çœ‹neuvectorçš„æ–‡ä»¶ç®¡ç†åŠŸèƒ½ï¼š</p>

<ul>
  <li>é¡µé¢/æ¥å£ç”¨æˆ·ä¸‹å‘çš„æ–‡ä»¶è§„åˆ™å¦‚ä½•è®©æ¯ä¸ªèŠ‚ç‚¹çš„AgentæœåŠ¡æ„ŸçŸ¥çš„</li>
  <li>æ–‡ä»¶è§„åˆ™å¦‚ä½•å’Œå®¹å™¨å…³è”èµ·æ¥çš„ï¼ŒAgentä¸­æ˜¯å¦‚ä½•å¤„ç†çš„</li>
  <li>å¯¹æ–‡ä»¶æ‰§è¡Œè¯»å†™æ“ä½œåAgentå¦‚ä½•æ„ŸçŸ¥</li>
  <li>fanotify/inotifyæ€ä¹ˆå¤„ç†æ–‡ä»¶çš„æ“ä½œçš„</li>
  <li>æ–‡ä»¶ç®¡ç†æ€ä¹ˆä½“ç°å­¦ä¹ æ¨¡å¼ä¸‹å­¦ä¹ </li>
  <li>æ–‡ä»¶æ“ä½œå‘Šè­¦ä¿¡æ¯æ€ä¹ˆé‡‡é›†çš„ï¼Œå‘Šè­¦çš„è§„åˆ™æ˜¯ä»€ä¹ˆ</li>
</ul>

<p>ä¸‹é¢æˆ‘ä»¬å¸¦ç€è¿™å‡ ä¸ªé—®é¢˜ï¼Œæ¥çœ‹çœ‹æºç ï¼Œæˆ‘ä»¬å…ˆçœ‹ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚</p>

<h2 id="æºç ">æºç </h2>

<h3 id="ä¸‹å‘çš„æ–‡ä»¶è§„åˆ™å¦‚ä½•åˆ°è¾¾æ¯ä¸ªèŠ‚ç‚¹çš„agentæœåŠ¡">ä¸‹å‘çš„æ–‡ä»¶è§„åˆ™å¦‚ä½•åˆ°è¾¾æ¯ä¸ªèŠ‚ç‚¹çš„AgentæœåŠ¡</h3>
<p><img src="/blog/img/neuvector_file1.png" alt="neuvector file" /></p>

<p>æˆ‘ä»¬å…ˆçœ‹çœ‹ç•Œé¢æ–°å¢æ–‡ä»¶è§„åˆ™çš„æµç¨‹ï¼š</p>

<ul>
  <li>è·å–groupå¯¹è±¡ï¼Œè·å–groupä¸­profileå’Œruleä¸¤ç»„æ•°æ®</li>
  <li>profileæ˜¯æ–‡ä»¶è§„åˆ™ï¼Œruleæ˜¯æ–‡ä»¶è§„åˆ™ä¸­åº”ç”¨è§„åˆ™</li>
  <li>å°†æ–°å¢æ•°æ®å’Œå·²æœ‰æ•°æ®åˆå¹¶ï¼Œç„¶åä¿å­˜åˆ°æ•°æ®åº“</li>
</ul>

<p>handlerFileMonitorConfigï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre></td><td class="rouge-code"><pre>func handlerFileMonitorConfig(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
    ...
    // Check if we can config the profile. Only need authorize group
    grp, err := cacher.GetGroupBrief(group, false, acc)
    if err != nil {
        restRespNotFoundLogAccessDenied(w, login, err)
        return
    }

    if grp.Kind != share.GroupKindContainer {
        // "nodes" : share.GroupKindNode
        log.WithFields(log.Fields{"group": group, "kind": grp.Kind}).Error("Get profile failed!")
        restRespError(w, http.StatusBadRequest, api.RESTErrObjectNotFound)
        return
    }

    var profChanged bool
    profConf, profRev := clusHelper.GetFileMonitorProfile(group)
    ruleConf, ruleRev := clusHelper.GetFileAccessRule(group)

    ...
    // validate add
    if config.AddFilters != nil {
        for _, filter := range config.AddFilters {
            path := filter.Filter
            filter.Filter = filepath.Clean(filter.Filter)
            if filter.Filter == "." || filter.Filter == "/" {
                restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest,
                    fmt.Sprintf("Unsupported filter: %s[%s]", path, filter.Filter))
                return
            }

            // append the "/" back
            if path[len(path)-1:] == "/" {
                filter.Filter += "/"
            }

            base, regex, ok := parseFileFilter(filter.Filter)
            if !ok {
                restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest,
                    fmt.Sprintf("Unsupported filter: %s", filter.Filter))
                return
            }

            for i, cfilter := range profConf.Filters {
                if cfilter.Filter == filter.Filter {
                    // conflict, delete predefined
                    if !cfilter.CustomerAdd {
                        profConf.Filters = append(profConf.Filters[:i], profConf.Filters[i+1:]...)
                        // replace the rule below
                        idx := utils.FilterIndexKey(cfilter.Path, cfilter.Regex)
                        delete(ruleConf.Filters, idx)
                        break
                    } else {
                        restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest,
                            fmt.Sprintf("duplicate filter: %s", filter.Filter))
                        return
                    }
                }
            }
            flt := share.CLUSFileMonitorFilter{
                Filter:      filter.Filter,
                Path:        base,
                Regex:       regex,
                Recursive:   filter.Recursive,
                CustomerAdd: true,
            }
            if fileAccessOptionSet.Contains(filter.Behavior) {
                flt.Behavior = filter.Behavior
            } else {
                restRespErrorMessage(w, http.StatusBadRequest, api.RESTErrInvalidRequest, "Invalid File access option")
                return
            }

            profConf.Filters = append(profConf.Filters, flt)
            // add rule
            idx := utils.FilterIndexKey(flt.Path, flt.Regex)
            capps := make([]string, len(filter.Apps))
            for j, app := range filter.Apps {
                capps[j] = app
            }
            frule := &amp;share.CLUSFileAccessFilterRule{
                Apps:        capps,
                CreatedAt:   tm,
                UpdatedAt:   tm,
                Behavior:    flt.Behavior,
                CustomerAdd: true,
            }
            ruleConf.Filters[idx] = frule
            profChanged = true
        }
    }

    ...

    if profChanged {
        // Write to cluster
        if err := clusHelper.PutFileMonitorProfile(group, profConf, profRev); err != nil {
            log.WithFields(log.Fields{"error": err}).Error("Write cluster fail")
            restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
            return
        }
    }
    // Write access rule
    if err := clusHelper.PutFileAccessRule(group, ruleConf, ruleRev); err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Write cluster fail")
        restRespError(w, http.StatusInternalServerError, api.RESTErrFailWriteCluster)
        return
    }

    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>çœ‹çœ‹æ•°æ®æ€ä¹ˆä¿å­˜çš„ï¼Œè¿™é‡Œæœ‰ä¸ªå°å‘ï¼š</p>
<ul>
  <li>é»˜è®¤æ•°æ®ä¿å­˜åœ¨/object/config/file_monitor/<group-name>ä¸‹é¢</group-name></li>
  <li>åœ¨ä¿å­˜æ•°æ®å‰è¿˜æœ‰ä¸€ä¸ªDuplicateNetworkKeyæ“ä½œï¼Œä¼šå°†æ•°æ®ä¿å­˜ä¸€ä»½åˆ°/node/[node-id]/common/profile/file/<group-name>ä¸‹é¢</group-name></li>
  <li>åé¢é‚£ä¸ªä¿å­˜ä½ç½®çš„æ•°æ®ä¼šè¢«æ¯ä¸ªenforcer watch</li>
</ul>

<p>PutFileMonitorProfile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>func (m clusterHelper) PutFileMonitorProfile(name string, conf *share.CLUSFileMonitorProfile, rev uint64) error {
    key := share.CLUSFileMonitorKey(name)
    value, _ := json.Marshal(conf)
    m.DuplicateNetworkKey(key, value)
    return cluster.PutRev(key, value, rev)
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ä¸Šé¢çœ‹äº†controllerä¸­æ•°æ®ä¿å­˜æµç¨‹ï¼Œä¸‹é¢æ¥çœ‹çœ‹enforcerä¸­æ•°æ®watchæµç¨‹</p>

<p>å’Œå…¶ä»–åŠŸèƒ½ç±»ä¼¼ï¼Œè‚¯å®šæœ‰ä¸ªåœ°æ–¹åœ¨watchè¿™ä¸ªæ•°æ®å˜åŒ–ï¼Œç„¶åæ‰§è¡Œä¸€äº›æ“ä½œ,è¿™é‡Œå…ˆçœ‹file_monitoréƒ¨åˆ†çš„é€»è¾‘ï¼ˆaccess_ruleæ˜¯ç±»ä¼¼çš„ï¼‰</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>func profileDerivedProc(nType cluster.ClusterNotifyType, key string, value []byte) {
    which := share.CLUSNetworkKey2Subject(key)
    value, _ = utils.UnzipDataIfValid(value)
    // log.WithFields(log.Fields{"key": key}).Debug("GRP:")
    switch which {
    case share.ProfileGroup:                     // group
        systemConfigGroup(nType, key, value)
    case share.ProfileProcess:                   // process
        profileConfigGroup(nType, key, value)
    case share.ProfileFileMonitor:               // file
        systemConfigFileMonitor(nType, key, value)  
    case share.ProfileFileAccess:                // fileAccess
        systemConfigFileAccessRule(nType, key, value)
    case share.ProfileScript:                    // script, è¿™ä¸ªåœ¨æ•°æ®åº“é‡Œæ²¡æ‰¾åˆ°
        systemConfigScript(nType, key, value)
    default:
        log.WithFields(log.Fields{"derived": which}).Debug("Miss handler")
    }
}

func systemConfigFileMonitor(nType cluster.ClusterNotifyType, key string, value []byte) {
  switch nType {
  case cluster.ClusterNotifyAdd, cluster.ClusterNotifyModify:
      ...
      updateGroupProfileCache(nType, name, profile)   // è¿™é‡Œé‡ç‚¹çœ‹ä¸‹è¿™ä¸ªå‡½æ•°
  case cluster.ClusterNotifyDelete: // required no group member that means no belonged containers, either
  }   }
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="æ–‡ä»¶è§„åˆ™å’Œç›‘æ§ç»„å®¹å™¨å…³è”">æ–‡ä»¶è§„åˆ™å’Œç›‘æ§ç»„ã€å®¹å™¨å…³è”</h3>

<p>ç”¨æˆ·è§„åˆ™åˆ›å»ºåä¿å­˜åˆ°æ•°æ®åº“ï¼Œenforcer watchåˆ°æ•°æ®å˜åŒ–ä¼šæ›´æ–°æœ¬åœ°å†…å­˜æ•°æ®</p>

<ul>
  <li>å¯¹æ¯”å†…å­˜æ•°æ®ï¼Œä¸ä¸€è‡´åˆ™æ›´æ–°</li>
  <li>targetsæ˜¯å½“å‰groupä¸­å®¹å™¨idåˆ—è¡¨</li>
  <li>å¯ä»¥çœ‹åˆ°grpNotifyFileæ˜¯å½“å‰èŠ‚ç‚¹æ‰€æœ‰å®¹å™¨idçš„é›†åˆ</li>
</ul>

<p>updateGroupProfileCache:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>func updateGroupProfileCache(nType cluster.ClusterNotifyType, name string, obj interface{}) bool {
    ...
    targets := utils.NewSet()
    switch obj.(type) {
    ...
    case share.CLUSFileMonitorProfile:
        file := obj.(share.CLUSFileMonitorProfile)
        if file.Mode != grpCache.file.Mode || len(grpCache.file.Filters) == 0 || reflect.DeepEqual(file.Filters, grpCache.file.Filters) == false {
            for i, _ := range file.Filters {
                file.Filters[i].DerivedGroup = name // late filled-up to save kv storages
            }
            grpCache.file = &amp;file
            targets = grpCache.members.Clone()
            if targets.Cardinality() &gt; 0 {
                fileUpdated = true
            }
        }
    ...

    if fileUpdated {
        grpNotifyFile = grpNotifyFile.Union(targets)
    }

    targets.Clear()
    targets = nil
    return true
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>çœ‹åˆ°è¿™é‡Œæœ‰ç‚¹å¥½å¥‡ï¼Œgroupå’Œå®¹å™¨æ˜¯æ€ä¹ˆå…³è”ä¸Šçš„ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢ä»£ç ä¸­grpCache.membersåœ¨å“ªé‡Œç»´æŠ¤çš„ï¼š</p>

<ul>
  <li>åœ¨enforcerä¸­ç›‘å¬runtimeäº‹ä»¶æ—¶ï¼Œä¼šç›‘å¬å®¹å™¨çš„åˆ›å»ºäº‹ä»¶ï¼Œå¯¹åº”çš„å›è°ƒå‡½æ•°æœ‰ä¸ªgroupWorkloadJoin</li>
  <li>åœ¨groupWorkloadJoinä¸­æ ¹æ®workloadçš„learnedGroupNameè·å–å¯¹åº”çš„ç³»ç»Ÿç»„ï¼Œç„¶ååŠ å…¥</li>
  <li>ç”¨æˆ·è‡ªå®šä¹‰ç»„æ ¹æ®Criteriaå’Œdomainæ¥è¯†åˆ«æ˜¯å¦åŒ…å«æ­¤workload</li>
</ul>

<p>registerEventHandlers&amp;groupWorkloadJoin:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>func registerEventHandlers() {
    ...
    evhdls.Register(EV_WORKLOAD_START, []eventHandlerFunc{
        groupWorkloadJoin,
        scanWorkloadAdd,
    })
    ...


func groupWorkloadJoin(id string, param interface{}) {
    ...
    if cache, ok := groupCacheMap[wlc.learnedGroupName]; !ok || isDummyGroupCache(cache) {
        ...
    } else {
        if !cache.members.Contains(wl.ID) {
            wlc.groups.Add(wlc.learnedGroupName)
            cache.members.Add(wl.ID)
            memberUpdated = true
            log.WithFields(log.Fields{"group": wlc.learnedGroupName}).Debug("Join group")
        }
    }

    // Join user defined group
    for _, cache := range groupCacheMap {
        if cache.group.CfgType == share.Learned {
            continue
        }

        if share.IsGroupMember(cache.group, wlc.workload) {
            if !cache.members.Contains(wl.ID) {
                wlc.groups.Add(cache.group.Name)
                cache.members.Add(wl.ID)
                memberUpdated = true
                log.WithFields(log.Fields{"group": cache.group.Name}).Debug("Join group")
            }
    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ°è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å†…å­˜ä¸­çš„æ•°æ®ä¸€ç›´åœ¨å®æ—¶æ›´æ–°ï¼Œç›‘æ§ç»„å’Œå®¹å™¨çš„å…³ç³»ä¹Ÿå»ºç«‹å¥½äº†ï¼Œæ–‡ä»¶è§„åˆ™ä¹Ÿæ›´æ–°åˆ°äº†æŒ‡å®šç»„å¯¹è±¡äº†ï¼Œå¦‚ä½•ä½¿ç”¨è¿™äº›æ•°æ®å‘¢ï¼Œæˆ‘ä»¬ç»§ç»­å¾€ä¸‹çœ‹</p>

<h3 id="å®šæ—¶æ›´æ–°fanotifyå…³æ³¨çš„å®¹å™¨æ–‡ä»¶">å®šæ—¶æ›´æ–°fanotifyå…³æ³¨çš„å®¹å™¨æ–‡ä»¶</h3>

<p><img src="/blog/img/neuvector_file2.png" alt="neuvector file" /></p>

<p>enforcerä¸­åˆ›å»ºäº†ä¸€ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œæ¯éš”5sæ‰§è¡Œä¸€æ¬¡ï¼Œéå†æ‰€æœ‰å®¹å™¨ï¼Œå°†å†…å­˜ä¸­çš„æ–‡ä»¶è§„åˆ™åº”ç”¨åˆ°çš„fanotifyä¸­</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>func fileMemberChanges(members utils.Set) {
    log.WithFields(log.Fields{"count": members.Cardinality()}).Debug("GRP:")
    for cid := range members.Iter() {
        ...
        c, ok := gInfo.activeContainers[id]
        gInfoRUnlock()
        if ok {
            applyFileGroupProfile(c)
        } ...
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åœ¨applyFileGroupProfileä¸­æ¶‰åŠä¸‰ä¸ªä¸»è¦æµç¨‹ï¼š</p>

<ul>
  <li>calculateFileGroupProfileï¼š æ ¹æ®ç”¨æˆ·åˆ›å»ºçš„æ–‡ä»¶è§„åˆ™ç­›é€‰å‡ºæ‰€æœ‰ç›¸å…³fileï¼Œæ ¹æ®ç›‘æ§ç»„æ¨¡å¼è®¾ç½®fileçš„maskå±æ€§</li>
  <li>æ›´æ–°å®¹å™¨matchRulesï¼šå°†è®¡ç®—åˆ°çš„file/accessè§„åˆ™æ·»åŠ åˆ°workloadå¯¹è±¡ä¸­ï¼ˆçº¯æ•°æ®è½¬æ¢å¤„ç†é€»è¾‘ï¼‰</li>
  <li>StartWatchï¼šå°†fileæ·»åŠ åˆ°fanotifyä¸­</li>
</ul>

<p>calculateFileGroupProfileå°±æ˜¯è·å–å†…å­˜ä¸­groupçš„fileå’Œaccessè§„åˆ™ï¼Œ
getFileMonitorProfileä¼šåŠ è½½æ•°æ®åº“ä¸­çš„æ•°æ®ï¼Œå¦‚æœå†…å­˜ä¸å­˜åœ¨æŒ‡å®šçš„groupä¿¡æ¯æ—¶</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>func calculateFileGroupProfile(id, svc string) (*share.CLUSFileMonitorProfile, *share.CLUSFileAccessRule, bool) {
    log.WithFields(log.Fields{"id": id, "svc": svc}).Debug("GRP: ")

    file := &amp;share.CLUSFileMonitorProfile{
        Filters:    make([]share.CLUSFileMonitorFilter, 0),
        FiltersCRD: make([]share.CLUSFileMonitorFilter, 0),
    }
    ...
    for _, grpCache := range grpProfileCacheMap {
        if grpCache.members.Contains(id) {
            file.Filters = append(file.Filters, grpCache.file.Filters...)
            file.FiltersCRD = append(file.FiltersCRD, grpCache.file.FiltersCRD...)
            mergeFileAccessProfile(access, grpCache.access)
        }
    }
    grpCacheLock.Unlock()

    // log.WithFields(log.Fields{"filter": file.Filters}).Debug("GRP:")
    ok, svc_file := getFileMonitorProfile(svc)
    if !ok {
        log.WithFields(log.Fields{"id": id, "svc": svc}).Debug("GRP: no file profile")
        return nil, nil, false
    }

    // basic information
    file.Group = svc_file.Group
    file.Mode = svc_file.Mode

    // merge regular files
    file.Filters = append(file.Filters, svc_file.Filters...)
    file.Filters = mergeFileMonitorProfile(file.Filters)
    ...
    return file, access, true
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æˆ‘ä»¬é‡ç‚¹çœ‹ä¸‹StartWatchæ–¹æ³•</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) StartWatch(id string, rootPid int, conf *FsmonConfig, capBlock, bNeuvectorSvc bool) {
    ...
    dirs, files := w.getCoreFile(id, rootPid, conf.Profile)

    w.fanotifier.SetMode(rootPid, access, perm, capBlock, bNeuvectorSvc)

    w.addCoreFile(id, dirs, files)

    w.fanotifier.StartMonitor(rootPid)
    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getCoreFile: ä¼šæ ¹æ®ç”¨æˆ·ä¸‹å‘çš„æ–‡ä»¶è§„åˆ™ï¼ˆpathå¯èƒ½å¸¦*ï¼‰ä¼šè·å–æ‰€æœ‰ç›¸å…³çš„ç›®å½•å’Œæ–‡ä»¶è·¯å¾„</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) getCoreFile(cid string, pid int, profile *share.CLUSFileMonitorProfile) (map[string]*osutil.FileInfoExt, []*osutil.FileInfoExt) {
    dirList := make(map[string]*osutil.FileInfoExt)
    singleFiles := make([]*osutil.FileInfoExt, 0)

    // get files and dirs from all filters
    for _, filter := range profile.Filters {
        flt := &amp;filterRegex{path: filterIndexKey(filter)}
        flt.regex, _ = regexp.Compile(fmt.Sprintf("^%s$", flt.path))
        bBlockAccess := filter.Behavior == share.FileAccessBehaviorBlock
        bUserAdded := filter.CustomerAdd
        if strings.Contains(filter.Path, "*") {
            subDirs := w.getSubDirList(pid, filter.Path, cid)
            for _, sub := range subDirs {
                singles := w.getDirAndFileList(pid, sub, filter.Regex, cid, flt, filter.Recursive, bBlockAccess, bUserAdded, dirList)
                singleFiles = append(singleFiles, singles...)
            }
        } else {
            singles := w.getDirAndFileList(pid, filter.Path, filter.Regex, cid, flt, filter.Recursive, bBlockAccess, bUserAdded, dirList)
            singleFiles = append(singleFiles, singles...)
        }
    }

    ...
    return dirList, singleFiles
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>SetModeï¼šå†…å­˜ä¸­åˆ›å»ºrootFdå¯¹è±¡ï¼Œéœ€è¦æ³¨æ„ä¸€ç‚¹å¦‚æœç›‘æ§ç»„æ˜¯ä¿æŠ¤æ¨¡å¼ä¼šè®¾ç½®permControlä¸ºtrueï¼Œè¿™ä¸ªåœ¨åé¢å¤„ç†æ–‡ä»¶äº‹ä»¶ä¼šç”¨åˆ°</p>

<p>addCoreFile</p>

<ul>
  <li>å‘fanotifyæ³¨å†Œéœ€è¦å…³æ³¨çš„æ–‡ä»¶åˆ—è¡¨ï¼Œä»¥åŠè®¾ç½®æ–‡ä»¶maskï¼Œä»¥addFileä¸ºä¾‹</li>
  <li>è¿™é‡Œå¦‚æœç›‘æ§pathæ˜¯åŒ…ç®¡ç†è·¯å¾„ä¼šé¢å¤–å†è°ƒç”¨inotifyæ¥ç›‘æ§</li>
</ul>

<p>addCoreFile&amp;addFile:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) addCoreFile(cid string, dirList map[string]*osutil.FileInfoExt, singleFiles []*osutil.FileInfoExt) {
    // add files
    for _, finfo := range singleFiles {
        // need to move the cross link files to dirs
        di, ok := dirList[filepath.Dir(finfo.Path)]
        if ok &amp;&amp; !isRunTimeAddedFile(finfo.Path) {
            finfo.Filter = di.Filter
            di.Children = append(di.Children, finfo)
        } else {
            finfo.ContainerId = cid
            w.addFile(finfo)
        }
    }

    // add directories
    ...
} 


func (w *FileWatch) addFile(finfo *osutil.FileInfoExt) {
    w.fanotifier.AddMonitorFile(finfo.Path, finfo.Filter, finfo.Protect, finfo.UserAdded, w.cbNotify, finfo)
    if _, path := global.SYS.ParseContainerFilePath(finfo.Path); packageFile.Contains(path) {
        w.inotifier.AddMonitorFile(finfo.Path, w.cbNotify, finfo)
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>fanotifyçš„addFile</p>

<ul>
  <li>pathå½¢å¦‚ï¼š/host/proc/17490/root/usr/binï¼Œè§£æåˆ°å®¹å™¨çš„pidå’Œæ“ä½œçš„æ–‡ä»¶è·¯å¾„</li>
  <li>fn.roots[rootPid]å¾—åˆ°å®¹å™¨çš„root fd</li>
  <li>è¿™é‡Œæ³¨æ„maskçš„å–å€¼é€»è¾‘ï¼šuserAdded/protectåŸºæœ¬éƒ½ç¬¦åˆå¯ä»¥å¿½ç•¥ï¼ŒpermControlè¡¨ç¤ºç›‘æ§ç»„æ˜¯ä¿æŠ¤æ¨¡å¼ï¼ŒconfigPermæ­£å¸¸æ˜¯trueï¼Œå¯ä»¥ç†è§£æˆç›‘æ§ç»„ä¿æŠ¤æ¨¡å¼ä¸‹é»˜è®¤ç»™æ–‡ä»¶è®¾ç½®maskæ˜¯FAN_OPEN_PERMï¼Œå…¶ä»–æƒ…å†µéƒ½æ˜¯FAN_OPENï¼Œè¿™ä¸ªéœ€è¦ç»“åˆåé¢fanotifyäº‹ä»¶çš„å¤„ç†æµç¨‹ä¸€èµ·çœ‹</li>
  <li>è¿™æ ·å°±å°†æ‰€æœ‰éœ€è¦ç›‘å¬çš„æ–‡ä»¶æƒé™ã€è·¯å¾„ã€å®¹å™¨idç­‰æ‰€æœ‰ç›¸å…³çš„å…ƒæ•°æ®éƒ½å¤„ç†å¥½äº†ï¼Œåé¢å°±æ˜¯å®é™…åº”ç”¨åˆ°fanotifyä¸­äº†</li>
</ul>

<p>addFile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre>func (fn *FaNotify) addFile(path string, filter interface{}, protect, isDir, userAdded bool, files map[string]interface{}, cb NotifyCallback, params interface{}) bool {
    ...
    rootPid, rPath, err := ParseMonitorPath(path)
    ...
    r, ok := fn.roots[rootPid]
    ...

    var mask uint64 = faMarkMask
    if userAdded || protect { // user-defined or protected: including access control
        if r.permControl { // protect mode
            if fn.configPerm { // system-wise : access control is available
                mask |= FAN_OPEN_PERM
            } else {
                mask |= FAN_OPEN
            }
        } else {
            mask |= FAN_OPEN
        }
    }

    var file *IFile
    if isDir {
        ...

    } else {
        if _, ok = r.paths[rPath]; ok {
            return false
        }
        file = &amp;IFile{
            path:    path,
            mask:    mask,
            params:  params,
            cb:      cb,
            filter:  filter.(*filterRegex),
            protect: protect,         // access control
            learnt:  r.accessMonitor, // discover mode
            userAdd: userAdded,
        }

        r.paths[rPath] = file
    }
...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>fa.StartMonitorçœŸæ­£å°†æ–‡ä»¶è§„åˆ™åº”ç”¨åˆ°fanotify</p>

<ul>
  <li>è¿™é‡Œçš„Markæ˜¯è°ƒç”¨fanotifyï¼Œç»™å‡ºéœ€è¦ç›‘æ§çš„æ–‡ä»¶è·¯å¾„ã€æ–‡ä»¶äº‹ä»¶ã€æƒé™</li>
  <li>addHostNetworkFilesCopiedFilesæ˜¯å°†hostnetworkçš„å®¹å™¨ä¸­ä¸€äº›é€šç”¨çš„æ–‡ä»¶ï¼ˆ/etc/hosts /etc/resolv.confï¼‰è¿›è¡Œç›‘æ§</li>
</ul>

<p>StartMonitor:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>func (fn *FaNotify) StartMonitor(rootPid int) bool {
    ...
    r, ok := fn.roots[rootPid]
    ...

    ppath := fmt.Sprintf(procRootMountPoint, rootPid)
    for dir, mask := range r.dirMonitorMap {
        path := ppath + dir
        if err := fn.fa.Mark(faMarkAddFlags, mask, unix.AT_FDCWD, path); err != nil {
            log.WithFields(log.Fields{"path": path, "error": err}).Error("FMON:")
        } else {
            mLog.WithFields(log.Fields{"path": path, "mask": fmt.Sprintf("0x%08x", mask)}).Debug("FMON:")
        }
    }

    //
    fn.addHostNetworkFilesCopiedFiles(r)
    return ok
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ°è¿™é‡Œå·²ç»å°†ç”¨æˆ·ä¸‹å‘çš„æ–‡ä»¶è§„åˆ™ï¼Œå…³è”åˆ°groupï¼Œå…³è”åˆ°å…·ä½“çš„å®¹å™¨ï¼ˆworkloadï¼‰ä¸­ï¼ŒåŒæ—¶ä¹Ÿå°†ç”¨æˆ·è§„åˆ™è¿›è¡Œé‡è®¡ç®—ï¼Œå¾—åˆ°ä¸€ä¸ªå®Œæ•´çš„æ–‡ä»¶é›†åˆï¼Œ
å°†éœ€è¦å…³æ³¨ï¼ˆç›‘æ§ï¼‰çš„æ–‡ä»¶ä»¥åŠäº‹ä»¶ç­‰ç»†èŠ‚éƒ½å‘Šè¯‰äº†fanotifyå’Œinotifyï¼Œä¸‹é¢å°±çœ‹çœ‹å®é™…watchåˆ°æ–‡ä»¶äº‹ä»¶åå¦‚ä½•å¤„ç†äº†</p>

<h3 id="æ–‡ä»¶æ“ä½œçš„æ„ŸçŸ¥">æ–‡ä»¶æ“ä½œçš„æ„ŸçŸ¥</h3>

<p><img src="/blog/img/neuvector_file3.png" alt="neuvector file" /></p>

<p>ä¸Šé¢ç›´æ¥è°ƒç”¨fn.fa.Markå»å‘Šè¯‰fanotifyéœ€è¦å…³æ³¨çš„æ–‡ä»¶ï¼Œä½†æ˜¯è¿™ä¸ªå¯¹è±¡å“ªé‡Œæ¥çš„ï¼Ÿ</p>

<ul>
  <li>NewFaNotify: åˆå§‹åŒ–fanotify</li>
  <li>NewInotify: åˆå§‹åŒ–inotify</li>
  <li>MonitorFileEventsï¼šç›‘å¬æ¥è‡ªfanotifyå’Œinotifyçš„æ–‡ä»¶äº‹ä»¶å¹¶å¤„ç†</li>
  <li>fw.loopï¼šè¿™ä¸ªåé¢æˆ‘ä»¬è®²</li>
</ul>

<p>NewFileWatcher:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>func NewFileWatcher(config *FileMonitorConfig) (*FileWatch, error) {
    ...

    n, err := NewFaNotify(config.EndChan, config.PidLookup, global.SYS)
    if err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Open fanotify fail")
        return nil, err
    }
    ni, err := NewInotify()
    if err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Open inotify fail")
        return nil, err
    }

    go n.MonitorFileEvents()
    go ni.MonitorFileEvents()

    fw := &amp;FileWatch{
        aufs:       config.IsAufs,
        fanotifier: n,
        inotifier:  ni,
        fileEvents: make(map[string]*fileMod),
        groups:     make(map[int]*groupInfo),
        sendrpt:    config.SendReport,
        sendRule:   config.SendAccessRule,
        estRuleSrc: config.EstRule,
        walkerTask: config.WalkerTask,
    }
    go fw.loop()
    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ–‡ä»¶äº‹ä»¶å¤„ç†ï¼š</p>

<ul>
  <li>åœ¨è·å–åˆ°æ–‡ä»¶äº‹ä»¶åï¼Œè·å–äº‹ä»¶ä¸­è¿›ç¨‹pidã€å®¹å™¨çš„root fdã€æ–‡ä»¶mask</li>
  <li>è¿™é‡Œå¦‚æœæ–‡ä»¶fmaskæ˜¯FAN_OPEN_PERMï¼Œåˆ™permæ˜¯1ã€‚å‰é¢æè¿‡å¦‚æœç›‘æ§ç»„æ˜¯ä¿æŠ¤æ¨¡å¼ï¼Œåˆ™ä¼šè®¾ç½®å¯¹åº”æ–‡ä»¶çš„maskæ˜¯FAN_OPEN_PERM</li>
  <li>respï¼šç”¨æ¥ç»™fanotifyå›å¤çš„ç»“æœï¼Œè®¡ç®—æ–¹å¼è§ä¸‹æ–‡çš„æµç¨‹å›¾</li>
</ul>

<p>handleEvents:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>func (fn *FaNotify) handleEvents() error {
    for {
        ev, err := fn.fa.GetEvent()
        ...
        pid := int(ev.Pid)
        fd := int(ev.File.Fd())
        fmask := uint64(ev.Mask)
        perm := (fmask &amp; (FAN_OPEN_PERM | FAN_ACCESS_PERM)) &gt; 0
        ...
        resp, mask, ifile, pInfo := fn.calculateResponse(pid, fd, fmask, perm)
        if perm {
            fn.fa.Response(ev, resp)
        }
        ev.File.Close()
        ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/blog/img/neuvector_file4.png" alt="neuvector file" /></p>

<ul>
  <li>respçš„å€¼é»˜è®¤æ˜¯true</li>
  <li>å¦‚æœæ–‡ä»¶è§„åˆ™æ˜¯ä¿æŠ¤æ¨¡å¼ï¼Œä¸”æ“ä½œè¿›ç¨‹ä¸åœ¨å…è®¸çš„åº”ç”¨ä¸­ï¼Œåˆ™respæ˜¯false</li>
  <li>å°†fmaskè½¬æ¢æˆmaskï¼ˆä¸€ä¸ªæ“ä½œä¼šæœ‰å¤šä¸ªäº‹ä»¶ï¼Œåªæœ‰ç¬¬ä¸€ä¸ªäº‹ä»¶ä¸­fmaskæ˜¯è®¾ç½®è¿‡çš„ï¼‰</li>
</ul>

<p>calculateResponse:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>func (fn *FaNotify) calculateResponse(pid, fd int, fmask uint64, perm bool) (bool, uint32, *IFile, *ProcInfo) {
    ...

    ifile, _, mask := fn.lookupFile(r, linkPath, pInfo)
    if ifile == nil {
        return true, mask, nil, nil
    }

    // log.WithFields(log.Fields{"protect": ifile.protect, "perm": perm, "path": linkPath, "ifile": ifile, "evMask": fmt.Sprintf("0x%08x", fmask)}).Debug("FMON:")

    // permition decision
    resp := true
    if ifile.protect { // always verify app for block-access
        resp = fn.lookupRule(r, ifile, pInfo, linkPath)
        // log.WithFields(log.Fields{"resp": resp}).Debug("FMON:")
    }

    if (fmask &amp; FAN_MODIFY) &gt; 0 {
        mask |= syscall.IN_MODIFY
        log.WithFields(log.Fields{"path": linkPath}).Info("FMON: modified")
    } else if (fmask &amp; FAN_CLOSE_WRITE) &gt; 0 {
        mask |= syscall.IN_CLOSE_WRITE
        log.WithFields(log.Fields{"path": linkPath}).Info("FMON: cls_wr")
    } else {
        mask |= syscall.IN_ACCESS
            log.WithFields(log.Fields{"path": linkPath}).Info("FMON: read")
        if fn.isFileException(false, linkPath, pInfo, mask) {
            resp = true
            mask &amp;^= syscall.IN_ACCESS
        }
    }

    if perm &amp;&amp; !resp {
        pInfo.Deny = true
        log.WithFields(log.Fields{"path": linkPath, "app": pInfo.Path}).Debug("FMON: denied")
    }
    return resp, mask, ifile, pInfo
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ç»¼åˆçœ‹ä¸€ä¸‹</p>

<p><img src="/blog/img/neuvector_file5.png" alt="neuvector file" /></p>

<ul>
  <li>åªæœ‰ç›‘æ§ç»„æ˜¯ä¿æŠ¤æ¨¡å¼çš„æ—¶å€™permæ‰æ˜¯true</li>
  <li>permæ˜¯trueçš„æ—¶å€™æ‰ä¼šç»™fanotifyå‘é€responseï¼Œå…¶ä»–æ—¶å€™éƒ½ä¸ä¼šå‘é€</li>
  <li>åªæœ‰æ–‡ä»¶è§„åˆ™æ˜¯ä¿æŠ¤æ¨¡å¼çš„æ—¶å€™respæ‰æ˜¯falseï¼Œå…¶ä»–æ—¶å€™éƒ½æ˜¯true</li>
  <li>æ¢å¥è¯è¯´ï¼šåªæœ‰ç›‘æ§ç»„æ˜¯ä¿æŠ¤æ¨¡å¼ä¸”æ–‡ä»¶è§„åˆ™æ˜¯ä¿æŠ¤æ¨¡å¼çš„æ—¶å€™fanotifyæ‰ä¼šé˜»æ–­æ–‡ä»¶æ“ä½œï¼Œå…¶ä»–éƒ½æ˜¯å…è®¸</li>
</ul>

<h3 id="è§„åˆ™å­¦ä¹ --å‘Šè­¦ä¿¡æ¯ä¸ŠæŠ¥">è§„åˆ™å­¦ä¹  &amp; å‘Šè­¦ä¿¡æ¯ä¸ŠæŠ¥</h3>

<p><img src="/blog/img/neuvector_file6.png" alt="neuvector file" /></p>

<p>å‰é¢çœ‹äº†æ–‡ä»¶äº‹ä»¶å¤„ç†æµç¨‹ï¼Œä½†æ˜¯æˆ‘ä»¬å¿½ç•¥äº†ä¸€ä¸ªç»†èŠ‚</p>

<ul>
  <li>è¿™é‡Œæœ‰ä¸ªchangeå‚æ•°ï¼Œç”¨æ¥åˆ¤æ–­æ–‡ä»¶æ˜¯å¦è¢«ä¿®æ”¹</li>
  <li>å½“fmaskæ˜¯FAN_CLOSE_WRITEè¡¨ç¤ºæ–‡ä»¶è¢«ä¿®æ”¹</li>
  <li>å½“æ–‡ä»¶è§„åˆ™æ˜¯å­¦ä¹ æ¨¡å¼ï¼Œæˆ–è€…ä¿æŠ¤æ¨¡å¼ä¸‹ä¿®æ”¹äº†æ–‡ä»¶ äº‹ä»¶éƒ½éœ€è¦report</li>
  <li>æ–‡ä»¶è¢«ä¿®æ”¹æˆ–è€…éœ€è¦ä¸ŠæŠ¥éƒ½éœ€è¦è°ƒç”¨å›è°ƒå‡½æ•°</li>
</ul>

<p>handleEvents:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>func (fn *FaNotify) handleEvents() error {
    for {
        ev, err := fn.fa.GetEvent()
        ...
        change := (fmask &amp; FAN_CLOSE_WRITE) &gt; 0
        // log.WithFields(log.Fields{"ifile": ifile, "pInfo": pInfo, "Resp": resp, "Change": change, "Perm": perm}).Debug("FMON:")

        var bReporting bool
        if ifile.learnt { // discover mode
            bReporting = ifile.userAdd // learn app for customer-added entry
        } else { // monitor or protect mode
            allowRead := resp &amp;&amp; !change
            bReporting = (allowRead == false) // allowed app by block_access
        }

        if bReporting || change { // report changed file
            ifile.cb(ifile.path, mask, ifile.params, pInfo)
        }
    }
    return nil
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å›è°ƒå‡½æ•°ï¼š åªæ˜¯å°†äº‹ä»¶æ›´æ–°æˆ–è€…ä¿å­˜åˆ°å†…å­˜ä¸­ï¼Œé‚£äº‹ä»¶åœ¨å“ªé‡Œå¤„ç†çš„å‘¢ï¼Ÿ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) cbNotify(filePath string, mask uint32, params interface{}, pInfo *ProcInfo) {
    //ignore the container remove event. they are too many
    if (mask&amp;syscall.IN_IGNORED) != 0 || (mask&amp;syscall.IN_UNMOUNT) != 0 {
        w.inotifier.RemoveMonitorFile(filePath)
        return
    }

    w.mux.Lock()
    defer w.mux.Unlock()
    if fm, ok := w.fileEvents[filePath]; ok {
        fm.mask |= mask
        fm.delay = 0
        fm.pInfo = append(fm.pInfo, pInfo)
    } else {
        pi := make([]*ProcInfo, 1)
        pi[0] = pInfo
        w.fileEvents[filePath] = &amp;fileMod{
            mask:  mask,
            delay: 0,
            finfo: params.(*osutil.FileInfoExt),
            pInfo: pi,
        }
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œåœ¨enforcerå¯åŠ¨æ—¶åˆ›å»ºäº†ä¸¤ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œåˆ†åˆ«ç”¨æ¥å¤„ç†äº‹ä»¶å’Œå­¦ä¹ è§„åˆ™ç”¨</p>

<ul>
  <li>HandleWatchedFilesä¼šæ ¹æ®è·¯å¾„ç±»å‹ï¼ˆæ–‡ä»¶è¿˜æ˜¯ç›®å½•ï¼‰è°ƒç”¨å¯¹åº”çš„å¤„ç†æ–¹æ³•</li>
  <li>reportLearningRules:åé¢ç»†è®²</li>
</ul>

<p>HandleWatchedFiles:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) HandleWatchedFiles() {
    events := make(map[string]*fileMod)
    w.mux.Lock()
    for filePath, fmod := range w.fileEvents {
        events[filePath] = fmod
        delete(w.fileEvents, filePath)
    }
    w.mux.Unlock()

    for fullPath, fmod := range events {
        pid, path := global.SYS.ParseContainerFilePath(fullPath)
        //to avoid false alarm of /etc/hosts and /etc/resolv.conf, check whether the container is still exist
        //these two files has attribute changed when the container leave
        //this maybe miss some events file changed right before container leave. But for these kind of event,
        //it is not useful if the container already leave
        //	log.WithFields(log.Fields{"pid": pid, "path": path, "pInfo": fmod.pInfo[0], "fInfo": fmod.finfo}).Debug("FMON:")
        //	if fmod.pInfo != nil {
        //		log.WithFields(log.Fields{"pInfo": fmod.pInfo[0]}).Debug("FMON:")
        //	}
        rootPath := global.SYS.ContainerProcFilePath(pid, "")
        if _, err := os.Stat(rootPath); err == nil &amp;&amp; path != "" {
            var event uint32
            info, _ := os.Lstat(fullPath)
            if fmod.finfo.FileMode.IsDir() {
                event = w.handleDirEvents(fmod, info, fullPath, path, pid)
            } else {
                event = w.handleFileEvents(fmod, info, fullPath, pid)
            }
            if event != 0 {
                w.learnFromEvents(pid, fmod, path, event)
            }
        }
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œæˆ‘ä»¬çœ‹çœ‹æ–‡ä»¶äº‹ä»¶å¤„ç†é€»è¾‘</p>

<ul>
  <li>å¦‚æœç”¨æˆ·åˆ é™¤æ–‡ä»¶è§„åˆ™åï¼Œä¼šæ›´æ–°enforcerå†…å­˜æ•°æ®ï¼Œä¹Ÿå°±æ˜¯å°†fileinfoåˆ é™¤ï¼Œè¿™é‡Œçš„infoå°±æ˜¯niläº†ï¼Œä¹Ÿå°±éœ€è¦è®©fanotifyçŸ¥é“ä¸å†éœ€è¦å…³æ³¨è¿™äº›æ–‡ä»¶äº†ï¼Œæ‰§è¡ŒRemoveMonitorFileæ–¹æ³•</li>
  <li>è¿™é‡Œçš„eventæ˜¯æ–‡ä»¶æ“ä½œç±»å‹å‚æ•°ï¼Œä¸ä¸ºç©ºæ—¶è°ƒç”¨learnFromEvents</li>
</ul>

<p>handleFileEvents:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) handleFileEvents(fmod *fileMod, info os.FileInfo, fullPath string, pid int) uint32 {
    var event uint32
    if info != nil {
        if info.Mode() != fmod.finfo.FileMode {
            //attribute is changed
            event = fileEventAttr
            fmod.finfo.FileMode = info.Mode()
        }
        // check the hash existing and match
        // skip directory new file event, report later
        hash, err := osutil.GetFileHash(fullPath)
        if err != nil &amp;&amp; !osutil.HashZero(fmod.finfo.Hash) ||
            err == nil &amp;&amp; hash != fmod.finfo.Hash ||
            fmod.finfo.Size != info.Size() {
            event |= fileEventModified
            fmod.finfo.Hash = hash
        } else if (fmod.mask &amp; syscall.IN_ACCESS) &gt; 0 {
            event |= fileEventAccessed
        }
        if (fmod.finfo.FileMode &amp; os.ModeSymlink) != 0 {
            //handle symlink
            rpath, err := osutil.GetContainerRealFilePath(pid, fullPath)
            if err == nil &amp;&amp; fmod.finfo.Link != rpath {
                event |= fileEventSymModified
            }
        }
        if (fmod.mask &amp; inodeChangeMask) &gt; 0 {
            w.removeFile(fullPath)
            w.addFile(fmod.finfo)
        }
    } else {
        //file is removed
        event = fileEventRemoved
        w.fanotifier.RemoveMonitorFile(fullPath)
    }
    return event
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è§„åˆ™å­¦ä¹ ï¼š</p>
<ul>
  <li>å¦‚æœç›‘æ§ç»„æ˜¯å­¦ä¹ æ¨¡å¼ï¼Œä¸”è¿›ç¨‹è®¿é—®çš„æ–‡ä»¶pathåŒ¹é…åˆ°æ–‡ä»¶è§„åˆ™ï¼Œä¼šå°†è¿›ç¨‹pathä¿å­˜åˆ°ç›‘æ§ç»„çš„learnRulesä¸­ï¼ˆè¿™ä¸ªæ•°æ®åé¢è¿˜æœ‰ä¸€ä¸ªå®šæ—¶ä»»åŠ¡æ¥å¤„ç†ï¼‰</li>
  <li>é€šè¿‡æœ€åçš„åˆ¤æ–­æ¡ä»¶å¯ä»¥çœ‹å‡ºï¼šéæ–‡ä»¶è®¿é—®æˆ–è€…éå­¦ä¹ æ¨¡å¼ä¸‹æ‰å‘å‘Šè­¦</li>
</ul>

<p>learnFromEvents:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) learnFromEvents(rootPid int, fmod *fileMod, path string, event uint32) {
    ...
    grp, ok := w.groups[rootPid]
    mode := grp.mode
    if mode == share.PolicyModeLearn {
        flt := fmod.finfo.Filter.(*filterRegex)
        if applyRules, ok := grp.applyRules[flt.path]; ok {
            learnRules, ok := grp.learnRules[flt.path]
            if !ok {
                learnRules = utils.NewSet()
            }
            for _, pf := range fmod.pInfo {
                // only use the process name/path as profile
                if pf != nil &amp;&amp; pf.Path != "" {
                    if !applyRules.Contains(pf.Path) &amp;&amp; !learnRules.Contains(pf.Path) {
                        learnRules.Add(pf.Path)
                        log.WithFields(log.Fields{"rule": pf.Path, "filter": flt}).Debug("FMON:")
                    }
                }
            }
            // for inotify, cannot learn
            if learnRules.Cardinality() &gt; 0 {
                grp.learnRules[flt.path] = learnRules
            }
        } else {
            log.WithFields(log.Fields{"path": path}).Debug("FMON: no access rules")
        }
    }
    w.mux.Unlock()

    if event != fileEventAccessed ||
        (mode == share.PolicyModeEnforce || mode == share.PolicyModeEvaluate) {
        w.sendMsg(fmod.finfo.ContainerId, path, event, fmod.pInfo, mode)
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="è§„åˆ™å­¦ä¹ ">è§„åˆ™å­¦ä¹ </h3>
<p>è¿™é‡Œæœ‰ä¸ªæ³¨æ„ç‚¹ï¼Œå­¦ä¹ æ¨¡å¼ä¸‹æ–‡ä»¶ç®¡ç†å’Œè¿›ç¨‹ç®¡ç†å·¥ä½œæ¨¡å¼æœ‰ç‚¹åŒºåˆ«ï¼š</p>
<ul>
  <li>è¿›ç¨‹ç®¡ç†ä¼šè‡ªåŠ¨å­¦ä¹ æ–°çš„è¿›ç¨‹è§„åˆ™ï¼Œå¹¶æ·»åŠ åˆ°æ•°æ®åº“</li>
  <li>æ–‡ä»¶ç®¡ç†çš„è§„åˆ™å¿…é¡»æ‰‹åŠ¨åˆ›å»ºï¼Œåªä¼šè‡ªåŠ¨å­¦ä¹ åº”ç”¨å¹¶æ·»åŠ åˆ°å¯¹åº”çš„è§„åˆ™ä¸­ï¼ˆè§„åˆ™å…è®¸çš„åº”ç”¨å±æ€§ï¼‰</li>
</ul>

<p>åœ¨enforcerä¸­è¿˜æœ‰ä¸€ä¸ªå®šæ—¶ä»»åŠ¡ï¼Œç”¨æ¥å¤„ç†å†…å­˜ä¸­å­¦ä¹ åˆ°çš„æ–‡ä»¶åº”ç”¨æ•°æ®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>func (w *FileWatch) reportLearningRules() {
    learnRules := make([]*share.CLUSFileAccessRuleReq, 0)
    w.mux.Lock()
    for _, grp := range w.groups {
        if len(grp.learnRules) &gt; 0 {
            for flt, rule := range grp.learnRules {
                for itr := range rule.Iter() {
                    prf := itr.(string)
                    rl := &amp;share.CLUSFileAccessRuleReq{
                        GroupName: grp.profile.Group,
                        Filter:    flt,
                        Path:      prf,
                    }
                    learnRules = append(learnRules, rl)
                }
            }
            grp.learnRules = make(map[string]utils.Set)
        }
    }
    w.mux.Unlock()
    if len(learnRules) &gt; 0 {
        w.sendRule(learnRules)
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å¯ä»¥çœ‹åˆ°é€šè¿‡grpcè°ƒç”¨ReportFileAccessRuleå°†å­¦ä¹ åˆ°çš„åº”ç”¨å‘é€ç»™controller</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>func sendLearnedFileAccessRule(rules []*share.CLUSFileAccessRuleReq) error {
    log.WithFields(log.Fields{"rules": len(rules)}).Debug("")
    client, err := getControllerServiceClient()
    if err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Failed to find ctrl client")
        return fmt.Errorf("Fail to find controller client")
    }

    ctx, cancel := context.WithTimeout(context.Background(), time.Second*3)
    defer cancel()

    ruleArray := &amp;share.CLUSFileAccessRuleArray{
        Rules: rules,
    }

    _, err = client.ReportFileAccessRule(ctx, ruleArray)
    if err != nil {
        log.WithFields(log.Fields{"error": err}).Debug("Fail to report file rule to controller")
        return fmt.Errorf("Fail to report file rule to controller")
    }
    return nil
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åœ¨controllerä¸­æœ‰ä¸ªå®šæ—¶ä»»åŠ¡æ¥å¤„ç†å­¦ä¹ åˆ°çš„æ–‡ä»¶è§„åˆ™ï¼Œæœ‰å…´è¶£çš„å¯ä»¥å†çœ‹ä¸‹ä»£ç ï¼Œæœ€ç»ˆå°±æ˜¯è°ƒç”¨PutFileAccessRuleä¿å­˜åˆ°æ•°æ®åº“</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>func FileReportBkgSvc() {
    for {
        if len(chanFileRules) &gt; 0 {
            if kv.IsImporting() {
                for i := 0; i &lt; len(chanFileRules); i++ {
                    &lt;-chanFileRules
                }
            } else {
                if lock, _ := clusHelper.AcquireLock(share.CLUSLockPolicyKey, policyClusterLockWait); lock != nil {
                    for i := 0; i &lt; len(chanFileRules) &amp;&amp; i &lt; 16; i++ {
                        rules := &lt;-chanFileRules
                        updateFileMonitorProfile(rules)
                    }
                    clusHelper.ReleaseLock(lock)
                }
            }
        } else {
            time.Sleep(time.Millisecond * 100) // yield
        }
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="æ€»ç»“">æ€»ç»“</h2>

<p>æˆ‘ä»¬ä»å‡ ä½ç»´åº¦å»çœ‹å¾…æ–‡ä»¶ç®¡ç†è¿™ä¸ªåŠŸèƒ½ï¼Œäº†è§£äº†æ–‡ä»¶è§„åˆ™å¦‚ä½•ä¸‹å‘åˆ°enforcerï¼Œenforcerå¦‚ä½•ç›‘æ§å½“å‰èŠ‚ç‚¹æ‰€æœ‰å®¹å™¨çš„æ–‡ä»¶æ“ä½œï¼Œæ–‡ä»¶äº‹ä»¶å¦‚ä½•å¤„ç†ï¼Œ
æ–‡ä»¶å­¦ä¹ å¦‚ä½•å®ç°ã€‚æœ€ç»ˆå‘ˆç°åœ¨æˆ‘ä»¬é¢å‰çš„æ–‡ä»¶ç®¡ç†æ˜¯è¿™æ ·çš„ï¼š</p>

<table>
  <thead>
    <tr>
      <th>å¯¹è±¡</th>
      <th>æ¨¡å¼</th>
      <th>Â </th>
      <th>Â </th>
      <th>Â </th>
      <th>Â </th>
      <th>Â </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ç›‘æ§ç»„</td>
      <td>å­¦ä¹ </td>
      <td>å­¦ä¹ </td>
      <td>å‘Šè­¦</td>
      <td>å‘Šè­¦</td>
      <td>ä¿æŠ¤</td>
      <td>ä¿æŠ¤</td>
    </tr>
    <tr>
      <td>æ–‡ä»¶è§„åˆ™</td>
      <td>å‘Šè­¦</td>
      <td>ä¿æŠ¤</td>
      <td>å‘Šè­¦</td>
      <td>ä¿æŠ¤</td>
      <td>å‘Šè­¦</td>
      <td>ä¿æŠ¤</td>
    </tr>
    <tr>
      <td>è¯»å‘Šè­¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
    </tr>
    <tr>
      <td>å†™å‘Šè­¦</td>
      <td>æ˜¯</td>
      <td>æ˜¯</td>
      <td>æ˜¯</td>
      <td>æ˜¯</td>
      <td>æ˜¯</td>
      <td>å¦</td>
    </tr>
    <tr>
      <td>é˜»æ–­&amp;å‘Šè­¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>å¦</td>
      <td>æ˜¯</td>
    </tr>
  </tbody>
</table>

<p>è¿›ç¨‹ç®¡ç†å’Œæ–‡ä»¶ç®¡ç†çš„ä»£ç æµç¨‹åŸºæœ¬ä¸€è‡´ï¼Œå¯ä»¥å‚è€ƒæ¥çœ‹</p>

<p>ä»¥ä¸Šæ˜¯ä»£ç é€»è¾‘ä»¥åŠä¸€äº›ä¸ªäººç†è§£ï¼Œæœ‰é—®é¢˜çš„åœ°æ–¹å¯ä»¥åŠæ—¶å¾®ä¿¡è”ç³»æˆ‘æ›´æ­£</p>
:ET
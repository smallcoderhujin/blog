I"€J<h2 id="èƒŒæ™¯">èƒŒæ™¯</h2>
<p>tungstenfabric cnié€šè¿‡watch kubernetes apiserverä¸­æŒ‡å®šçš„èµ„æºï¼Œå¹¶åœ¨sdnä¸­åˆ›å»ºå¯¹åº”çš„ç½‘ç»œè®¾å¤‡æ¥å®ç°å¯¹åº”åŠŸèƒ½ã€‚æœ¬æ–‡é‡ç‚¹ä»‹ç»cnié’ˆå¯¹networkpolicyçš„å¤„ç†ï¼Œæ ¹æ®æºç é€æ­¥åˆ†æã€‚</p>

<h2 id="æ¶æ„æµç¨‹å›¾">æ¶æ„&amp;æµç¨‹å›¾</h2>
<p><img src="http://hujin.dynv6.net:50008/index.php?user/publicLink&amp;fid=826f91FDc9_ivLXP-2TgqvVlTnWAWUUm5hE6qr_ef-KVP_3RWxuNClqp0L86chmPdHcV9GGK4fY5BLr3ualYY8IkFXQI_OHUoI2btmUla-PRxN494bUH8DsY7FAajC-fCOHFQHOBwYVnU8BSRZOxaVGZsp2WPTQ&amp;file_name=/arch_network_policy.png" alt="arch_network_policy" /></p>

<h2 id="æºç è§£æ">æºç è§£æ</h2>

<p>åœ¨processæ–¹æ³•ä¸­ä¼šå¤„ç†networkpolicyçš„åˆ›å»ºã€æ›´æ–°å’Œåˆ é™¤ã€‚è¿™é‡Œæˆ‘ä»¬å…ˆçœ‹ä¸‹åˆ›å»ºå’Œæ›´æ–°</p>

<p>åˆ›å»ºå’Œæ›´æ–°æ–¹æ³•ä¸­æœ‰ä¸¤ä¸ªæ­¥éª¤ï¼š</p>

<ul>
  <li>_add_labelsï¼š è·å–networkpolicyä¸­selectorç›¸å…³çš„lableï¼Œå¹¶åœ¨sdnä¸­åˆ›å»ºæˆ–æ›´æ–°å¯¹åº”çš„tagèµ„æº</li>
  <li>vnc_network_policy_addï¼šåœ¨sdnä¸­åˆ›å»ºå¯¹åº”çš„apsï¼ˆapplication policy setï¼‰policyèµ„æº</li>
</ul>

<p>åœ¨_add_labelsä¸­ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>def _get_np_pod_selector(self, spec):
    pod_selector = spec.get('podSelector')
    if not pod_selector or 'matchLabels' not in pod_selector:
        labels = {}
    else:
        labels = pod_selector.get('matchLabels')
    return labels

def _add_labels(self, event, namespace, np_uuid):
    all_labels = []
    spec = event['object']['spec']
    if spec:
        # Get pod selector labels.
        all_labels.append(self._get_np_pod_selector(spec))

        # Get ingress podSelector labels
        ingress_spec_list = spec.get("ingress", [])
        for ingress_spec in ingress_spec_list:
            from_rules = ingress_spec.get('from', [])
            for from_rule in from_rules:
                if 'namespaceSelector' in from_rule:
                    all_labels.append(
                        from_rule.get('namespaceSelector').get(
                            'matchLabels', {}))
                if 'podSelector' in from_rule:
                    all_labels.append(
                        from_rule.get('podSelector').get('matchLabels', {}))

        # Call label mgmt API.
        self._labels.process(np_uuid, list_curr_labels_dict=all_labels)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œå¯ä»¥çœ‹åˆ°ç¨‹åºä»networkpolicyçš„specä¸­è·å–äº†podSelectorï¼Œä»ingressä¸­è·å–äº†namespaceSelectorå’ŒpodSelectorå¯¹åº”çš„labelsï¼Œæœ€ç»ˆåœ¨labelsèµ„æºçš„processæ–¹æ³•ä¸­è¿›è¡Œå¤„ç†</p>

<p>æˆ‘ä»¬åœ¨label_cache.pyçš„processä¸­å¯ä»¥çœ‹åˆ°ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>def process(self, obj_uuid, curr_labels={}, list_curr_labels_dict=[]):
    ...
    all_labels = set()

    if list_curr_labels_dict:
        for labels_dict in list_curr_labels_dict:
            for key, value in labels_dict.items():
                key, value = self._validate_key_value(key, value)
                # Construct the label key.
                label_key = self._update_label_to_guid_cache(key, value, obj_uuid)
                # Construct a set of all input label keys.
                all_labels.add(label_key)
    ... é’ˆå¯¹ä»networkpolicyä¸­ä¼ å…¥çš„labelsï¼Œåœ¨è¿™é‡Œåšäº†validateï¼Œç„¶ååšäº†_update_label_to_guid_cacheï¼š

def _update_label_to_guid_cache(self, key, value, obj_uuid):

    # Construct the label key.
    label_key = self.get_key(key, value)

    # If an entry exists for this label, add guid to the existing entry.
    # If not, create one.
    ltg_cache = XLabelCache.k8s_label_to_guid_cache[self.resource_type]
    if label_key in ltg_cache:
        ltg_cache[label_key].add(obj_uuid)
    else:
        ltg_cache[label_key] = {obj_uuid}
        XLabelCache.label_add_cb(key, value)

    return label_key
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œå°†keyå’Œvalueå…ˆè½¬æ¢æˆsdnçš„tagæ ¼å¼ï¼Œå†è°ƒç”¨XLabelCache.label_add_cbæ–¹æ³•å¤„ç†ï¼Œè¿™é‡Œçš„label_add_cbæ–¹æ³•å¤„ç†å®é™…æ˜¯ä¸€ä¸ªcallbackæ–¹æ³•ï¼Œæ˜¯åœ¨åˆå§‹åŒ–æ—¶ä¼ å…¥çš„ï¼Œå…·ä½“çœ‹ä¸‹ï¼š</p>

<p>vnc_kubernetes.pyä¸­åˆå§‹åŒ–VncKubernetesæ—¶ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>def __init_():
    ...
    # Register label add and delete callbacks with label management entity.
    label_cache.XLabelCache.register_label_add_callback(VncKubernetes.create_tags)
    label_cache.XLabelCache.register_label_delete_callback(VncKubernetes.delete_tags)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>label_cache.pyä¸­</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>@classmethod
def register_label_add_callback(cls, cb_func):
    cls.label_add_cb = cb_func
    
@classmethod
def register_label_delete_callback(cls, cb_func):
    cls.label_delete_cb = cb_func
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œåœ¨åˆå§‹åŒ–VncKubernetesæ˜¯ï¼Œè°ƒç”¨label_cache.pyä¸­çš„register_label_add_callbackï¼Œæ³¨å†Œäº†ä¸¤ä¸ªæ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯åˆ›å»ºå’Œåˆ é™¤tag</p>

<p>æˆ‘ä»¬åœ¨vnc_tag.pyæœ€ç»ˆæ‰¾åˆ°å®é™…è°ƒç”¨vncåˆ›å»ºå’Œåˆ é™¤tagçš„æ–¹æ³•ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre>def create(self, type, value):
    tag_name = "=".join([type, value])
    tag = Tag(name=tag_name,
              parent_obj=self.proj_obj,
              tag_type_name=type,
              tag_value=value)
    try:
        TagKM.add_annotations(self, tag, "default", tag_name)
        self._vnc_lib.tag_create(tag)
    except RefsExistError:
        # Tags cannot be updated.
        pass

    try:
        tag_obj = self._vnc_lib.tag_read(fq_name=tag.get_fq_name())
    except NoIdError as e:
        self._logger.error(
            "Unable to create tag [%s]. Error [%s]" %
            (tag.get_fq_name(), str(e)))
        return
    # Cache the object in local db.
    TagKM.locate(tag_obj.uuid)

def delete(self, type, value):
    tag_uuid = TagKM.get_fq_name_to_uuid(
        self._construct_tag_fq_name(type, value))
    try:
        self._vnc_lib.tag_delete(id=tag_uuid)

        TagKM.delete(tag_uuid)
        self._logger.debug("Tag (%s) deleted successfully."
                           % (self._construct_tag_fq_name(type, value)))
    except RefsExistError:
        self._logger.debug("Tag (%s) deletion failed. Tag is in use."
                           % (self._construct_tag_fq_name(type, value)))
    except NoIdError:
        self._logger.debug("Tag delete failed. Tag [%s] not found."
                           % (self._construct_tag_fq_name(type, value)))

    return
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸€ä¸ªç»“è®ºï¼Œå½“å­˜åœ¨å¤šä¸ªk8sé›†ç¾¤çš„æ—¶å€™ï¼Œå®é™…tagæ˜¯å…±äº«çš„ã€‚ä¹Ÿå°±æ˜¯è¯´å½“å¤šä¸ªk8sé›†ç¾¤æœ‰åŒåçš„labelsæ—¶ï¼Œå®é™…åœ¨sdnä¸­æ˜¯å¤ç”¨çš„</p>

<p>çœ‹å®Œlabelsçš„æ“ä½œåï¼Œæˆ‘ä»¬çœ‹ä¸‹networkpolicyåœ¨sdnä¸­çš„å¤„ç†å§ï¼Œåœ¨çœ‹ä¹‹å‰æˆ‘ä»¬éœ€è¦çŸ¥é“ä¸€ä¸ªå‰ææ¡ä»¶ï¼š</p>

<p>vnc_kubernetes.pyä¸­ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>def _provision_cluster(self):
    ...
    # Create application policy set for the cluster project.
    VncSecurityPolicy.create_application_policy_set(
        vnc_kube_config.application_policy_set_name(), namespace=proj_obj.name)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æˆ‘ä»¬å‘ç°kube-managerå®é™…ä¼šä¸ºæ¯ä¸ªæ¥å…¥tungstenfabricçš„k8sé›†ç¾¤åˆ›å»ºä¸€ä¸ªapsï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªé˜²ç«å¢™ã€‚ç„¶ååˆå§‹åŒ–ä¸‰ä¸ªpolicyï¼Œåˆ†åˆ«æ˜¯ï¼šdenyall/allowall/ingressï¼Œç„¶ååˆ›å»ºä¸€äº›åˆå§‹åŒ–è§„åˆ™ï¼Œè¿™é‡Œä¸å±•å¼€è®²äº†ã€‚</p>

<p>äº†è§£è¿™ä¸ªå‰æåï¼Œæˆ‘ä»¬çœ‹ä¸‹é¢çš„ä»£ç å°±å®¹æ˜“ç†è§£äº†ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>def vnc_network_policy_add(self, event, namespace, name, uid):
    spec = event['object']['spec']
    if not spec:
        self._logger.error(
            "%s - %s:%s Spec Not Found"
            % (self._name, name, uid))
        return

    fw_policy_uuid = VncSecurityPolicy.create_firewall_policy(name, namespace,
                                                              spec, k8s_uuid=uid)
    VncSecurityPolicy.add_firewall_policy(fw_policy_uuid)

    # Update kube config db entry for the network policy.
    np = NetworkPolicyKM.find_by_name_or_uuid(uid)
    if np:
        fw_policy_obj = self._vnc_lib.firewall_policy_read(id=fw_policy_uuid)
        np.set_vnc_fq_name(":".join(fw_policy_obj.get_fq_name()))
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å®é™…k8sä¸­çš„networkpolicyå¯¹åº”sdnçš„èµ„æºå°±æ˜¯aps policyèµ„æºã€‚ä¸Šé¢å¯ä»¥çœ‹åˆ°ä¼šåœ¨create_firewall_policyä¸­åˆ›å»ºä¸€ä¸ªpolicyï¼Œç„¶åå°†policyç»‘å®šåˆ°apsä¸­ï¼Œä¹Ÿå°±æ˜¯add_firewall_policyçš„åŠ¨ä½œã€‚è¿™é‡Œæˆ‘ä»¬é‡ç‚¹çœ‹ä¸‹create_firewall_policyï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="rouge-code"><pre>@classmethod
def create_firewall_policy(cls, name, namespace, spec, tag_last=False,
                           tag_after_tail=False, is_global=False,
                           k8s_uuid=None):
    ...
    policy_name = cls.get_firewall_policy_name(name, namespace, is_global)
    fw_policy_obj = FirewallPolicy(policy_name, pm_obj)

    custom_ann_kwargs = {}
    custom_ann_kwargs['k8s_uuid'] = k8s_uuid
    curr_fw_policy = None
    fw_rules_del_candidates = set()

    # If this firewall policy already exists, get its uuid.
    fw_policy_uuid = VncSecurityPolicy.get_firewall_policy_uuid(
        name, namespace, is_global)
    ...

    # Parse input spec and construct the list of rules for this FW policy.
    fw_rules = []
    deny_all_rule_uuid = None
    egress_deny_all_rule_uuid = None

    if spec is not None:
        fw_rules, deny_all_rule_uuid, egress_deny_all_rule_uuid =\
            FWRule.parser(name, namespace, pm_obj, spec)

    for rule in fw_rules:
        try:
            FirewallRuleKM.add_annotations(cls, rule, namespace, rule.name)
            rule_uuid = cls.vnc_lib.firewall_rule_create(rule)
        except RefsExistError:
            cls.vnc_lib.firewall_rule_update(rule)
            rule_uuid = rule.get_uuid()

            # The rule is in use and needs to stay.
            # Remove it from delete candidate collection.
            if fw_rules_del_candidates and\
               rule_uuid in fw_rules_del_candidates:
                fw_rules_del_candidates.remove(rule_uuid)

        rule_obj = cls.vnc_lib.firewall_rule_read(id=rule_uuid)
        FirewallRuleKM.locate(rule_uuid)

        fw_policy_obj.add_firewall_rule(
            rule_obj,
            cls.construct_sequence_number(fw_rules.index(rule)))

    if deny_all_rule_uuid:
        VncSecurityPolicy.add_firewall_rule(
            VncSecurityPolicy.deny_all_fw_policy_uuid, deny_all_rule_uuid)
        custom_ann_kwargs['deny_all_rule_uuid'] = deny_all_rule_uuid

    if egress_deny_all_rule_uuid:
        VncSecurityPolicy.add_firewall_rule(
            VncSecurityPolicy.deny_all_fw_policy_uuid,
            egress_deny_all_rule_uuid)
        custom_ann_kwargs['egress_deny_all_rule_uuid'] =\
            egress_deny_all_rule_uuid

    FirewallPolicyKM.add_annotations(
        VncSecurityPolicy.vnc_security_policy_instance,
        fw_policy_obj, namespace, name, None, **custom_ann_kwargs)

    try:
        fw_policy_uuid = cls.vnc_lib.firewall_policy_create(fw_policy_obj)
    except RefsExistError:
    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œæ˜¯åˆ›å»ºaps policyï¼Œå¹¶æå–specä¸­çš„æ•°æ®ç”Ÿæˆpolicy ruleå¹¶åˆ›å»ºï¼Œç„¶åå°†ruleç»‘å®šåˆ°policyä¸­ï¼Œè¿™é‡Œéœ€è¦é‡ç‚¹çœ‹ä¸‹FWRule.parserï¼Œçœ‹çœ‹å¦‚ä½•è½¬åŒ–policy ruleçš„ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>@classmethod
def parser(cls, name, namespace, pobj, spec):

    fw_rules = []

    # Get pod selectors.
    podSelector_dict = cls._get_np_pod_selector(spec, namespace)
    tags = VncSecurityPolicy.get_tags_fn(podSelector_dict, True)

    deny_all_rule_uuid = None
    egress_deny_all_rule_uuid = None
    policy_types = spec.get('policyTypes', ['Ingress'])
    for policy_type in policy_types:
        if policy_type == 'Ingress':
            # Get ingress spec.
            ingress_spec_list = spec.get("ingress", [])
            for ingress_spec in ingress_spec_list:
                fw_rules +=\
                    cls.ingress_parser(
                        name, namespace, pobj, tags,
                        ingress_spec, ingress_spec_list.index(ingress_spec))

            # Add ingress deny-all for all other non-explicit traffic.
            deny_all_rule_name = namespace + "-ingress-" + name + "-denyall"
            deny_all_rule_uuid =\
                VncSecurityPolicy.create_firewall_rule_deny_all(
                    deny_all_rule_name, tags, namespace)

        if policy_type == 'Egress':
            # Get egress spec.
            egress_spec_list = spec.get("egress", [])
            for egress_spec in egress_spec_list:
                fw_rules +=\
                    cls.egress_parser(name, namespace, pobj, tags,
                                      egress_spec)
            # Add egress deny-all for all other non-explicit traffic.
            egress_deny_all_rule_uuid =\
                VncSecurityPolicy.create_firewall_rule_egress_deny_all(
                    name, namespace, tags)

    return fw_rules, deny_all_rule_uuid, egress_deny_all_rule_uuid
</pre></td></tr></tbody></table></code></pre></div></div>

<p>_get_np_pod_selectorä¼šè·å–specä¸­podSelectorå’Œnamespaceä¸¤ä¸ªlabelçš„æ•°æ®ï¼Œç„¶åé€šè¿‡get_tags_fnæŸ¥è¯¢sdnä¸­å·²ç»åˆ›å»ºçš„tagæ•°æ®ï¼Œè¿™é‡Œçš„tagæ•°æ®æœ‰ï¼š</p>

<ul>
  <li>podselector: matchLabels: xxx:xxx</li>
  <li>namespace:xxx</li>
</ul>

<p>ç„¶åä¼šè·å–specä¸­ingresså’Œegresså¯¹åº”çš„è§„åˆ™ï¼Œé€šè¿‡ingress_parserå’Œegress_parseråšè½¬æ¢ï¼Œè½¬æ¢æˆå…·ä½“çš„sdn policy ruleæ ¼å¼ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„ï¼š</p>

<ul>
  <li>ä¼šä¼˜å…ˆæ ¹æ®specä¸­ingresså’Œegressæ·»åŠ çš„è§„åˆ™åˆ›å»ºpolicy rule</li>
  <li>ingressæœ«å°¾ä¼šæ·»åŠ ä¸€æ¡é»˜è®¤è§„åˆ™ï¼Œä¸€æ¡ingress denyè§„åˆ™åˆ°æ­¤é›†ç¾¤å¯¹åº”çš„deny-allçš„policyä¸­</li>
  <li>å¦‚æœæŒ‡å®šäº†egressè§„åˆ™ï¼Œä¼šåœ¨æœ«å°¾æ·»åŠ ä¸€æ¡denyè§„åˆ™åˆ°æ­¤é›†ç¾¤çš„deny-allçš„policyä¸­ï¼Œå³ç»‘å®šæ­¤tagçš„èµ„æºæ— æ³•è®¿é—®ä»»æ„å…¶ä»–èµ„æº</li>
</ul>

<p>è‡³æ­¤ï¼Œæˆ‘ä»¬åŸºæœ¬åˆ†æå®Œäº†networkpolicyçš„å·¥ä½œæµç¨‹ï¼Œä½†æ˜¯æˆ‘ä»¬ä¼¼ä¹æ¼äº†ç‚¹ä»€ä¹ˆï¼Œpolicyå’Œruleéƒ½åˆ›å»ºäº†ï¼Œä½†æ˜¯å¦‚ä½•ç”Ÿæ•ˆçš„ï¼Ÿ èµ„æºå’Œtagçš„ç»‘å®šå…³ç³»å‘ç”Ÿåœ¨ä»€ä¹ˆæ—¶å€™ï¼Ÿè¿™é‡Œæˆ‘ä»¬é€šè¿‡podçš„åˆ›å»ºæµç¨‹æ¥åˆ†æä¸‹</p>

<p>åœ¨podåˆ›å»ºè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°æœ‰æ¶‰åŠlabelsçš„å¤„ç†æµç¨‹(vnc_pod.py process):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>def process(self, event):
    ...
    # Add implicit namespace labels on this pod.
    labels.update(self._get_namespace_labels(pod_namespace))
    self._labels.process(pod_id, labels) å’Œä¹‹å‰çš„æµç¨‹ç±»ä¼¼ï¼Œè¿™é‡Œä¼šè·å–podä¸­metadataçš„labelï¼Œå¹¶åˆ›å»ºå‡ºå¯¹åº”çš„tagèµ„æº

def vnc_pod_add(self, pod_id, pod_name, pod_namespace, pod_node, node_ip,
                labels, vm_vmi, fixed_ip=None, annotations_bandwidth_str=None):
    vm = VirtualMachineKM.get(pod_id)
    if vm:
        vm.pod_namespace = pod_namespace
        if not vm.virtual_router:
            self._link_vm_to_node(vm, pod_node, node_ip)
        self._set_label_to_pod_cache(labels, vm)

        # Update tags.
        self._set_tags_on_pod_vmi(pod_id)

        return vm æˆ‘ä»¬åœ¨åˆ›å»ºpodçš„æµç¨‹ä¸­å‘ç°ï¼Œ_set_tags_on_pod_vmiä¼šå°†tagç»‘å®šåˆ°å…·ä½“çš„èµ„æºä¸­

def _set_tags_on_pod_vmi(self, pod_id, old_lables=None):
    vmi_obj_list = []
    vm = VirtualMachineKM.get(pod_id)
    if vm:
        for vmi_id in list(vm.virtual_machine_interfaces):
            vmi_obj_list.append(
                self._vnc_lib.virtual_machine_interface_read(id=vmi_id))

    for vmi_obj in vmi_obj_list:
        labels = self._labels.get_labels_dict(pod_id)
        self._vnc_lib.set_tags(vmi_obj, labels)
        if old_lables:
            diff_labels = {k:old_lables[k] for k in old_lables if k not in labels.keys()}
            for k, v in diff_labels.items():
                self._vnc_lib.unset_tag(vmi_obj, k)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ä»£ç ä¸­å…ˆä»VirtualMachineKMä¸­æŸ¥è¯¢å‡ºvmå¯¹è±¡ï¼Œæ­¤æ—¶vmå¯¹è±¡å·²ç»åœ¨ä¸Šé¢çš„_set_label_to_pod_cacheæ–¹æ³•ä¸­å°†laablesè®¾ç½®è¿›å»äº†ï¼›
å…ˆä»æ•°æ®åº“ä¸­æŸ¥è¯¢å‡ºå¯¹åº”çš„vmiåˆ—è¡¨ï¼Œç„¶åä¾æ¬¡è°ƒç”¨vncçš„set_tagsæ–¹æ³•ï¼Œå°†tagå’Œvmiè¿›è¡Œç»‘å®š</p>

<p>è¿™æ ·æ•´ä¸ªæµç¨‹å°±å®Œæˆäº†ã€‚åˆ›å»ºsdnèµ„æºçš„æ—¶å€™ï¼Œåˆ›å»ºtagå¹¶ç»‘å®šåˆ°èµ„æºä¸­ï¼›åˆ›å»ºnetworkpolicyæ—¶ï¼Œç®¡ç†ç»‘å®šä¸åŒtagçš„èµ„æºçš„è¡Œä¸º</p>
:ET
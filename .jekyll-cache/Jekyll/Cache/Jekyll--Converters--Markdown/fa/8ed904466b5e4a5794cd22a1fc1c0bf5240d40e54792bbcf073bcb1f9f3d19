I"ÆF<h2 id="èƒŒæ™¯">èƒŒæ™¯</h2>
<p>æœ€è¿‘çœ‹åˆ°å®‰å…¨å®¹å™¨ç›¸å…³çš„æ–‡ç« ï¼Œæƒ³ç€çœ‹çœ‹kataçš„ç½‘ç»œå®ç°</p>

<h2 id="æ¶æ„å›¾">æ¶æ„å›¾</h2>
<p><img src="/blog/img/kata1.png" alt="kataè°ƒç”¨æµç¨‹" />
åœ¨k8sä¸­é…ç½®ä½¿ç”¨containerdä½œä¸ºruntime-endpointå®ç°ï¼Œåœ¨containerdä¸­é…ç½®runtimeæ”¯æŒruncå’Œkataï¼Œéƒ¨ç½²æµç¨‹å‚è€ƒã€2ã€‘</p>

<h2 id="å®ç°">å®ç°</h2>
<p><img src="/blog/img/kata2.png" alt="kataç½‘ç»œ" /></p>

<ul>
  <li>é»˜è®¤æƒ…å†µä¸‹ï¼Œcontainerdå®¹å™¨åœ¨åˆ›å»ºsandboxçš„æ—¶å€™ï¼Œåˆ›å»ºå¯¹åº”çš„netnså‡ºæ¥</li>
  <li>åœ¨åˆ›å»ºå®¹å™¨æ—¶ï¼Œcniè´Ÿè´£åˆ›å»ºå’Œé…ç½®å®¹å™¨ç½‘å¡ï¼Œä¹Ÿå°±æ˜¯åœ¨å¯¹åº”çš„netnsä¸­åˆ›å»ºå’Œé…ç½®å®¹å™¨ç½‘å¡</li>
  <li>åœ¨åˆ›å»ºkataå®¹å™¨æ—¶ï¼Œkata-runtimeä¼šåœ¨å®¹å™¨ä¸­åˆ›å»ºä¸€ä¸ªqemuè™šæ‹Ÿæœºï¼Œä½¿ç”¨tap0_kataç½‘å¡ä½œä¸ºè™šæ‹Ÿæœºçš„è™šæ‹Ÿç½‘å¡</li>
  <li>è¿™é‡Œkata-runtimeæ”¯æŒå¤šç§æ–¹å¼å°†æµé‡ä»å®¹å™¨åŸæœ¬çš„vethè®¾å¤‡mirroråˆ°è™šæ‹Ÿæœºçš„tapè®¾å¤‡ä¸Š</li>
  <li>æ”¯æŒçš„mirroræ–¹å¼æœ‰: macvtap noneå’Œtcfilterï¼Œé»˜è®¤ä½¿ç”¨tcfilter</li>
</ul>

<p>containerdä»£ç ï¼šåˆ›å»ºnetns</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>// RunPodSandbox creates and starts a pod-level sandbox. Runtimes should ensure
// the sandbox is in ready state.
func (c *criService) RunPodSandbox(ctx context.Context, r *runtime.RunPodSandboxRequest) (_ *runtime.RunPodSandboxResponse, retErr error) {
    config := r.GetConfig()
    log.G(ctx).Debugf("Sandbox config %+v", config)
    ...
    if _, err := c.client.SandboxStore().Create(ctx, sandboxInfo); err != nil {
	    return nil, fmt.Errorf("failed to save sandbox metadata: %w", err)
    }
    ...
    if podNetwork {
        netStart := time.Now()
        // If it is not in host network namespace then create a namespace and set the sandbox
        // handle. NetNSPath in sandbox metadata and NetNS is non empty only for non host network
        // namespaces. If the pod is in host network namespace then both are empty and should not
        // be used.
        var netnsMountDir = "/var/run/netns"
        if c.config.NetNSMountsUnderStateDir {
            netnsMountDir = filepath.Join(c.config.StateDir, "netns")
        }
        sandbox.NetNS, err = netns.NewNetNS(netnsMountDir)
        if err != nil {
            return nil, fmt.Errorf("failed to create network namespace for sandbox %q: %w", id, err)
        }
        // Update network namespace in the store, which is used to generate the container's spec
        sandbox.NetNSPath = sandbox.NetNS.GetPath()
       ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>kata-runtimeä»£ç ï¼šåˆ›å»ºqemuè™šæ‹Ÿæœºå¹¶attachç½‘å¡</p>

<p>å¯ä»¥çœ‹åˆ°åœ¨åˆ›å»ºå®Œè™šæ‹Ÿæœºåæ‰§è¡Œäº†AddEndpointsæ“ä½œï¼Œä¹Ÿå°±æ˜¯attachäº†ç½‘å¡</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>// startVM starts the VM.
func (s *Sandbox) startVM(ctx context.Context, prestartHookFunc func(context.Context) error) (err error) {
    span, ctx := katatrace.Trace(ctx, s.Logger(), "startVM", sandboxTracingTags, map[string]string{"sandbox_id": s.id})
    defer span.End()

    s.Logger().Info("Starting VM")

    ...

    if err := s.network.Run(ctx, func() error {
        if s.factory != nil {
            vm, err := s.factory.GetVM(ctx, VMConfig{
                HypervisorType:   s.config.HypervisorType,
                HypervisorConfig: s.config.HypervisorConfig,
                AgentConfig:      s.config.AgentConfig,
            })
            if err != nil {
                return err
            }

            return vm.assignSandbox(s)
        }

        return s.hypervisor.StartVM(ctx, VmStartTimeout)
    }); err != nil {
        return err
    }

    ...

    // 1. Do not scan the netns if we want no network for the vmm.
    // 2. In case of vm factory, scan the netns to hotplug interfaces after vm is started.
    // 3. In case of prestartHookFunc, network config might have been changed. We need to
    //    rescan and handle the change.
    if !s.config.NetworkConfig.DisableNewNetwork &amp;&amp; (s.factory != nil || prestartHookFunc != nil) {
        if _, err := s.network.AddEndpoints(ctx, s, nil, true); err != nil {
            return err
        }
    }

    s.Logger().Info("VM started")

    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>kata-runtimeä»£ç ï¼šattachç½‘å¡æµç¨‹</p>

<p>ä¼šåœ¨æŒ‡å®šçš„network namespaceä¸­æ‰§è¡ŒaddSingleEndpointæ–¹æ³•</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>// Add adds all needed interfaces inside the network namespace.
func (n *LinuxNetwork) AddEndpoints(ctx context.Context, s *Sandbox, endpointsInfo []NetworkInfo, hotplug bool) ([]Endpoint, error) {
    span, ctx := n.trace(ctx, "AddEndpoints")
    katatrace.AddTags(span, "type", n.interworkingModel.GetModel())
    defer span.End()

    if endpointsInfo == nil {
        if err := n.addAllEndpoints(ctx, s, hotplug); err != nil {
            return nil, err
        }
    } else {
        for _, ep := range endpointsInfo {
            if err := doNetNS(n.netNSPath, func(_ ns.NetNS) error {
                if _, err := n.addSingleEndpoint(ctx, s, ep, hotplug); err != nil {
                    n.eps = nil
                    return err
                }

                return nil
            }); err != nil {
                return nil, err
            }
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>æ”¯æŒçƒ­æŒ‚è½½ç½‘å¡</li>
  <li>æ”¯æŒå¤šç§ç½‘å¡ç±»å‹ï¼Œè¿™é‡Œé»˜è®¤ä½¿ç”¨tuntap</li>
  <li>ç½‘å¡æ”¯æŒé™é€Ÿ</li>
  <li>æ”¯æŒå¤šç½‘å¡ï¼ˆçœ‹åˆ°æœ‰å•ç‹¬çš„attach_interfaceæ¥å£ï¼‰</li>
</ul>

<p>addSingleEndpoint</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre>func (n *LinuxNetwork) addSingleEndpoint(ctx context.Context, s *Sandbox, netInfo NetworkInfo, hotplug bool) (Endpoint, error) {
    ...
        if socketPath != "" {
            networkLogger().WithField("interface", netInfo.Iface.Name).Info("VhostUser network interface found")
            endpoint, err = createVhostUserEndpoint(netInfo, socketPath)
        } else if netInfo.Iface.Type == "macvlan" {
            networkLogger().Infof("macvlan interface found")
            endpoint, err = createMacvlanNetworkEndpoint(idx, netInfo.Iface.Name, n.interworkingModel)
        } else if netInfo.Iface.Type == "macvtap" {
            networkLogger().Infof("macvtap interface found")
            endpoint, err = createMacvtapNetworkEndpoint(netInfo)
        } else if netInfo.Iface.Type == "tap" {
            networkLogger().Info("tap interface found")
            endpoint, err = createTapNetworkEndpoint(idx, netInfo.Iface.Name)
        } else if netInfo.Iface.Type == "tuntap" {
            if netInfo.Link != nil {
                switch netInfo.Link.(*netlink.Tuntap).Mode {
                case 0:
                    // mount /sys/class/net to get links
                    return nil, fmt.Errorf("Network device mode not determined correctly. Mount sysfs in caller")
                case 1:
                    return nil, fmt.Errorf("tun networking device not yet supported")
                case 2:
                    networkLogger().Info("tuntap tap interface found")
                    endpoint, err = createTuntapNetworkEndpoint(idx, netInfo.Iface.Name, netInfo.Iface.HardwareAddr, n.interworkingModel)
                default:
                    return nil, fmt.Errorf("tuntap network %v mode unsupported", netInfo.Link.(*netlink.Tuntap).Mode)
                }
            }
        } else if netInfo.Iface.Type == "veth" {
            networkLogger().Info("veth interface found")
            endpoint, err = createVethNetworkEndpoint(idx, netInfo.Iface.Name, n.interworkingModel)
        } else if netInfo.Iface.Type == "ipvlan" {
            networkLogger().Info("ipvlan interface found")
            endpoint, err = createIPVlanNetworkEndpoint(idx, netInfo.Iface.Name)
        } else {
            return nil, fmt.Errorf("Unsupported network interface: %s", netInfo.Iface.Type)
        }
    }
    ...
    networkLogger().WithField("endpoint-type", endpoint.Type()).WithField("hotplug", hotplug).Info("Attaching endpoint")
    if hotplug {
        if err := endpoint.HotAttach(ctx, s.hypervisor); err != nil {
            return nil, err
        }
    } else {
        if err := endpoint.Attach(ctx, s); err != nil {
            return nil, err
        }
    }
    ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>kata-runtimeä»£ç ï¼šå¼•æµå®ç°</p>

<ul>
  <li>
    <p>åˆ›å»ºç½‘å¡, è¿™é‡Œç¬¬ä¸€å¼ ç½‘å¡åç§°æ˜¯tap0_kataï¼Œè™šæ‹Ÿæœºå†…éƒ¨æ˜¯eth0</p>

    <p>func createTuntapNetworkEndpoint(idx int, ifName string, hwName net.HardwareAddr, internetworkingModel NetInterworkingModel) (*TuntapEndpoint, error) {
      â€¦</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>  netPair, err := createNetworkInterfacePair(idx, ifName, internetworkingModel)
  if err != nil {
      return nil, err
  }

  endpoint := &amp;TuntapEndpoint{
      NetPair: netPair,
      TuntapInterface: TuntapInterface{
          Name: fmt.Sprintf("eth%d", idx),
          TAPIface: NetworkInterface{
              Name:     fmt.Sprintf("tap%d_kata", idx),
              HardAddr: fmt.Sprintf("%s", hwName), //nolint:gosimple
          },
      },
      EndpointType: TuntapEndpointType,
  }
  ...
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<p>åœ¨attachæ–¹æ³•ä¸­ä¼šè°ƒç”¨xConnectVMNetworkï¼Œè¿™é‡Œé¢ä¼šå®ç°å®¹å™¨ç½‘ç»œçš„å¼•æµ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>// Attach for tun/tap endpoint adds the tap interface to the hypervisor.
func (endpoint *TuntapEndpoint) Attach(ctx context.Context, s *Sandbox) error {
    span, ctx := tuntapTrace(ctx, "Attach", endpoint)
    defer span.End()

    h := s.hypervisor
    if err := xConnectVMNetwork(ctx, endpoint, h); err != nil {
        networkLogger().WithError(err).Error("Error bridging virtual endpoint")
        return err
    }

    return h.AddDevice(ctx, endpoint, NetDev)
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å¼•æµé©±åŠ¨æœ‰macvtap å’Œtcfilterï¼Œå…¶ä¸­é»˜è®¤ä½¿ç”¨tcfilter</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>func setupTCFiltering(ctx context.Context, endpoint Endpoint, queues int, disableVhostNet bool) error {
    ...
    if err := addQdiscIngress(tapAttrs.Index); err != nil {
        return err
    }

    if err := addQdiscIngress(attrs.Index); err != nil {
        return err
    }

    if err := addRedirectTCFilter(attrs.Index, tapAttrs.Index); err != nil {
        return err
    }

    if err := addRedirectTCFilter(tapAttrs.Index, attrs.Index); err != nil {
        return err
    }
...
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="demo">demo</h2>

<p>kataéƒ¨ç½²å¯ä»¥å‚è€ƒç½‘ä¸Šçš„æ–‡ç« ï¼Œè¿™é‡Œé€šè¿‡åˆ›å»ºä¸€ä¸ªkataå®¹å™¨ï¼ŒæŸ¥çœ‹å®¹å™¨å†…çš„æµé‡è½¬å‘</p>

<p>åˆ›å»ºkataå®¹å™¨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>[root@node1 kata]# cat nginx-kata.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-nginx-kata
spec:
  selector:
    matchLabels:
      run: my-nginx
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      runtimeClassName: kata
      containers:
      - name: my-nginx
        image: httpd:alpine
        ports:
        - containerPort: 80
      - name: my-redis
        image: redis
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æŸ¥çœ‹å®¹å™¨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>[root@node1 kata]# kubectl get pods -owide
NAME                             READY   STATUS    RESTARTS   AGE   IP               NODE    NOMINATED NODE   READINESS GATES
my-nginx-kata-8675cd7c89-wzgr2   2/2     Running   0          45s   10.244.166.150   node1   &lt;none&gt;           &lt;none&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æŸ¥çœ‹ç½‘ç»œå‘½åç©ºé—´</p>

<blockquote>
  <p>çœ‹åˆ°åœ¨netnsä¸­æœ‰ä¸¤å¼ ç½‘å¡ï¼Œeth0å’Œtap0_kata</p>
</blockquote>

<blockquote>
  <p>eth0ç½‘å¡æ˜¯vethç±»å‹ï¼Œç±»ä¼¼æ™®é€šå®¹å™¨çš„ç½‘å¡</p>
</blockquote>

<blockquote>
  <p>tap0_kataç½‘å¡æ˜¯tapç±»å‹ï¼Œå¯åŠ¨qemuè™šæ‹Ÿæœºæ—¶ä½¿ç”¨çš„è™šæ‹Ÿç½‘å¡</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>[root@node1 kata]# ip netns exec cni-d27eff58-b9c9-a258-3a1e-a34528d9796f ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
4: eth0@if29: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1430 qdisc noqueue state UP group default qlen 1000
    link/ether fe:68:1c:e3:47:da brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 10.244.166.150/32 brd 10.244.166.150 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::fc68:1cff:fee3:47da/64 scope link
       valid_lft forever preferred_lft forever
5: tap0_kata: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1430 qdisc mq state UNKNOWN group default qlen 1000
    link/ether 76:c7:1b:ab:30:64 brd ff:ff:ff:ff:ff:ff
    inet6 fe80::74c7:1bff:feab:3064/64 scope link
       valid_lft forever preferred_lft forever
</pre></td></tr></tbody></table></code></pre></div></div>

<p>tcå¼•æµè§„åˆ™</p>

<ul>
  <li>å¯¹äºeth0ç½‘å¡çš„å…¥å£æµé‡é€šè¿‡tcè§„åˆ™mirroråˆ°tap0_kataç½‘å¡ä¸Š</li>
  <li>å¯¹äºtap0_kataçš„å…¥å£æµé‡é€šè¿‡tcè§„åˆ™mirroråˆ°eth0ç½‘å¡ä¸Š</li>
  <li>
    <p>è¿™æ ·ä¸€ä¸ªåŒå‘çš„æµé‡é€šé“å°±å»ºç«‹äº†</p>

    <p>[root@node1 kata]# ip netns exec cni-d27eff58-b9c9-a258-3a1e-a34528d9796f tc -s qdisc show dev eth0
  qdisc noqueue 0: root refcnt 2
   Sent 0 bytes 0 pkt (dropped 0, overlimits 0 requeues 0)
   backlog 0b 0p requeues 0
  qdisc ingress ffff: parent ffff:fff1 â€”â€”â€”â€”â€”-
   Sent 480 bytes 5 pkt (dropped 0, overlimits 0 requeues 0)
   backlog 0b 0p requeues 0</p>

    <p>[root@node1 kata]# ip netns exec cni-d27eff58-b9c9-a258-3a1e-a34528d9796f tc -s filter show dev eth0 ingress
  filter protocol all pref 49152 u32
  filter protocol all pref 49152 u32 fh 800: ht divisor 1
  filter protocol all pref 49152 u32 fh 800::800 order 2048 key ht 800 bkt 0 terminal flowid ??? not_in_hw  (rule hit 5 success 5)
    match 00000000/00000000 at 0 (success 5 )
          action order 1: mirred (Egress Redirect to device tap0_kata) stolen
          index 1 ref 1 bind 1 installed 439 sec used 437 sec
          Action statistics:
          Sent 480 bytes 5 pkt (dropped 0, overlimits 0 requeues 0)
          backlog 0b 0p requeues 0</p>

    <p>[root@node1 kata]# ip netns exec cni-d27eff58-b9c9-a258-3a1e-a34528d9796f tc -s filter show dev tap0_kata ingress
  filter protocol all pref 49152 u32
  filter protocol all pref 49152 u32 fh 800: ht divisor 1
  filter protocol all pref 49152 u32 fh 800::800 order 2048 key ht 800 bkt 0 terminal flowid ??? not_in_hw  (rule hit 12 success 12)
    match 00000000/00000000 at 0 (success 12 )
          action order 1: mirred (Egress Redirect to device eth0) stolen
          index 2 ref 1 bind 1 installed 451 sec used 165 sec
          Action statistics:
          Sent 768 bytes 12 pkt (dropped 0, overlimits 0 requeues 0)
          backlog 0b 0p requeues 0</p>
  </li>
</ul>

<h2 id="æ€»ç»“">æ€»ç»“</h2>
<ul>
  <li>ä»ä¸Šé¢çš„ä»£ç åˆ†æï¼Œå¤§è‡´äº†è§£äº†kataçš„æµé‡è·¯å¾„ï¼Œç±»ä¼¼åœ¨ä¸€ä¸ªæ™®é€šå®¹å™¨åŸºç¡€ä¸Šå¯åŠ¨äº†ä¸€ä¸ªqemuè¿›ç¨‹</li>
  <li>é€šè¿‡tc mirroræœºåˆ¶ï¼Œå°†å®¹å™¨vethç½‘å¡æµé‡é•œåƒåˆ°tapç½‘å¡ï¼ˆå½“å‰é€šè¿‡macvtapå­æ¥å£æ–¹å¼ä¹Ÿç±»ä¼¼ï¼‰</li>
</ul>
:ET
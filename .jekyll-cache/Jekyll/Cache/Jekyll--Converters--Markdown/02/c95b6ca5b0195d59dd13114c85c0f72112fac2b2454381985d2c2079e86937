I"¡7<h2 id="èƒŒæ™¯">èƒŒæ™¯</h2>
<p>Neuvectorå®‰å…¨åŸºçº¿æ”¯æŒ CIS Benchmark æ ‡å‡†ï¼Œå¯å¯¹å®¹å™¨ã€é•œåƒã€Registerã€ä¸»æœºã€kubernetes è¿›è¡Œå®‰å…¨æ ‡å‡†æ£€æŸ¥ï¼Œå¤šç»´åº¦å±•ç°å®¹å™¨èµ„äº§çš„åŸºçº¿åˆè§„æƒ…å†µå¹¶å¸®åŠ©å»ºç«‹å®¹å™¨è¿è¡Œç¯å¢ƒä¸‹çš„æœ€ä½³åŸºçº¿é…ç½®ï¼Œå‡å°‘æ”»å‡»é¢
NeuVector çš„åˆè§„æ€§å®¡æ ¸åŒ…æ‹¬ CIS åŸºçº¿æµ‹è¯•ã€è‡ªå®šä¹‰æ£€æŸ¥ã€æœºå¯†å®¡æ ¸ä»¥åŠ PCIã€GDPR å’Œå…¶ä»–æ³•è§„çš„è¡Œä¸šæ ‡å‡†æ¨¡æ¿æ‰«æã€‚æœ¬æ–‡å°†é€šè¿‡æºç çš„æ–¹å¼åˆ†æåˆè§„æ€§æ£€æµ‹çš„å…·ä½“å®ç°</p>

<h2 id="æ¶æ„å›¾">æ¶æ„å›¾</h2>
<p><img src="/blog/img/neuvector_bench.png" alt="neuvector bench" /></p>

<p>ä»æ¶æ„å›¾ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ¶‰åŠä¸¤ä¸ªæ¨¡å—ï¼Œåˆ†åˆ«æ˜¯:</p>
<ul>
  <li>controller:è´Ÿè´£æä¾›APIæ¥å£ï¼Œä¿å­˜ä¸šåŠ¡æ•°æ®</li>
  <li>agentï¼ˆenforceï¼‰ï¼šå…·ä½“æ‰§è¡Œåˆè§„æ€§æ£€æµ‹çš„æ¨¡å—</li>
</ul>

<h2 id="æºç ">æºç </h2>

<p>é¦–å…ˆåœ¨rest.goä¸­æŸ¥çœ‹benchç›¸å…³çš„æ¥å£ï¼Œæˆ‘ä»¬ä¸»è¦çœ‹ä¸‹ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>r.GET("/v1/bench/host/:id/docker", handlerDockerBench)
r.POST("/v1/bench/host/:id/docker", handlerDockerBenchRun)
r.GET("/v1/bench/host/:id/kubernetes", handlerKubeBench)
r.POST("/v1/bench/host/:id/kubernetes", handlerKubeBenchRun)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œæˆ‘ä»¬é€šè¿‡dockeråˆè§„æ€§æ£€æµ‹æ¥äº†è§£å…·ä½“çš„å®ç°ç»†èŠ‚ï¼Œåœ¨handlerDockerBenchRunæ–¹æ³•ä¸­è·å–node idï¼Œå¹¶æŸ¥è¯¢åˆ°è¿™ä¸ªnodeèŠ‚ç‚¹çš„agentä¿¡æ¯ï¼Œ
æ–¹ä¾¿åé¢çš„rpcè°ƒç”¨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>func RunDockerBench(agentID string) error {
    client, err := findEnforcerServiceClient(agentID)
    if err != nil {
        return err
    }

    ctx, cancel := context.WithTimeout(context.Background(), defaultReqTimeout)
    defer cancel()

    _, err = client.RunDockerBench(ctx, &amp;share.RPCVoid{})
    return err
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ‡æ¢åˆ°agentçš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°RunDockerBenchæ–¹æ³•å®é™…åšçš„äº‹æƒ…æ˜¯è°ƒç”¨äº†RerunDockeræ–¹æ³•ï¼Œåœ¨RerunDockeræ–¹æ³•ä¸­æ‰§è¡Œçš„é€»è¾‘éå¸¸ç®€å•ï¼Œå°±æ˜¯reset
host timerå’Œcontainer timer, åŒæ—¶è®¾ç½®ä¸‹æ•°æ®åº“ä¸­å½“å‰èŠ‚ç‚¹benchä»»åŠ¡çš„çŠ¶æ€ä¸ºscheduled</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>func (b *Bench) RerunDocker() {
    log.Info("")

    if err := b.dockerCheckPrerequisites(); err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Cannot run Docker CIS benchmark")
        b.logBenchFailure(benchPlatDocker, share.BenchStatusNotSupport)
        b.putBenchReport(Host.ID, share.BenchDockerHost, nil, share.BenchStatusNotSupport)
    } else {
        b.hostTimer.Reset(hostTimerStart)
        b.conTimer.Reset(containerTimerStart)
        b.putBenchReport(Host.ID, share.BenchDockerHost, nil, share.BenchStatusScheduled)
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/blog/img/neuvector_bench2.png" alt="neuvector bench" />
é€šè¿‡ä¸Šå›¾æˆ‘ä»¬å‘ç°ï¼Œåœ¨agentå¯åŠ¨æ—¶ä¼šå¯åŠ¨ä¸€ä¸ªåå°ä»»åŠ¡BenchLoopï¼Œç”¨æ¥å®šæ—¶æŒ‡å®šå®¹å™¨ã€hostã€k8så¹³å°ã€è‡ªå®šä¹‰çš„åˆè§„æ€§æ£€æµ‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>func (b *Bench) BenchLoop() {
    var masterScript, workerScript, remediation string
    b.taskScanner = newTaskScanner(b, scanWorkerMax)
    //after the host bench, it will schedule a container bench automaticly even if no container
    for {
        select {
        case &lt;-b.hostTimer.C:
            b.doDockerHostBench()

        case &lt;-b.kubeTimer.C:
            ...

            b.doKubeBench(masterScript, workerScript, remediation)
        case &lt;-b.conTimer.C:
            containers := b.cloneAllNewContainers()
            if Host.CapDockerBench {
                b.doDockerContainerBench(containers)
            } else {
                b.putBenchReport(Host.ID, share.BenchDockerContainer, nil, share.BenchStatusFinished)
            }

            ...
        case &lt;-b.customConTimer.C:
            ...

            b.doContainerCustomCheck(wls)
        case &lt;-b.customHostTimer.C:
            b.doHostCustomCheck()
        }
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œåœ¨reset container timeråï¼Œä¼šç«‹å³è§¦å‘å®šæ—¶ä»»åŠ¡çš„æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œçš„doDockerContainerBenchæ–¹æ³•</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>func (b *Bench) doDockerContainerBench(containers map[string]string) error {
    b.putBenchReport(Host.ID, share.BenchDockerContainer, nil, share.BenchStatusRunning)
    if out, err := b.runDockerContainerBench(containers); err != nil {
        b.logBenchFailure(benchPlatDocker, share.BenchStatusDockerContainerFail)
        b.putBenchReport(Host.ID, share.BenchDockerContainer, nil, share.BenchStatusDockerContainerFail)
        return err
    } else {
        log.Info("Running benchmark checks done")

        list := b.getBenchMsg(out)
        b.assignDockerBenchMeta(list)

        b.putBenchReport(Host.ID, share.BenchDockerContainer, list, share.BenchStatusFinished)

        // Going through each container, write report and log
        ...
    }
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¿™é‡Œæˆ‘ä»¬é‡ç‚¹å…³æ³¨å‡ ä¸ªæ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯</p>
<ul>
  <li>runDockerContainerBenchï¼š å…·ä½“æ‰§è¡Œå®¹å™¨åˆè§„æ€§æ£€æµ‹ï¼Œåé¢é‡ç‚¹ä»‹ç»</li>
  <li>getBenchMsgï¼šå°†æ‰§è¡Œç»“æœæ ¼å¼åŒ–</li>
  <li>assignDockerBenchMetaï¼šæ‰§è¡Œç»“æœæ ¼å¼åŒ–ï¼Œä¸»è¦æ˜¯æ ¼å¼åŒ–åˆè§„é¡¹åç§°å’Œprofile</li>
  <li>putBenchReportï¼šå°†æ ¼å¼åŒ–åçš„ç»“æœä¿å­˜åˆ°æ•°æ®åº“ä¸­ï¼Œç­‰å¾…è·å–ç»“æœçš„apiè°ƒç”¨æ—¶ä»æ•°æ®åº“ä¸­è·å–</li>
</ul>

<p>ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹runDockerContainerBenchæ–¹æ³•ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>func (b *Bench) runDockerContainerBench(containers map[string]string) ([]byte, error) {
    ...

    if err := b.replaceDockerDaemonCmdline(srcContainerBenchSh, dstContainerBenchSh, cs); err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Replace container docker daemon cmdline error")
        return nil, fmt.Errorf("Replace container docker daemon cmdline error, error=%v", err)
    }

    args := []string{system.NSActRun, "-f", dstContainerBenchSh, "-m", global.SYS.GetMountNamespacePath(1)}
    var errb, outb bytes.Buffer

    log.WithFields(log.Fields{"args": args}).Debug("Running bench script")
    cmd := exec.Command(system.ExecNSTool, args...)
    cmd.SysProcAttr = &amp;syscall.SysProcAttr{Setsid: true}
    cmd.Stdout = &amp;outb
    cmd.Stderr = &amp;errb
    b.childCmd = cmd
    err := cmd.Start()
    ...
    return out, nil
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>è¯¥æ–¹æ³•é¦–å…ˆæ ¹æ®æ¨¡æ¿ç”Ÿæˆç›®æ ‡çš„cisæ£€æµ‹è„šæœ¬</p>
<ul>
  <li>æ¨¡æ¿ä½ç½®ï¼š/usr/local/bin/container.tmplï¼Œç”Ÿæˆæ–‡ä»¶ä½ç½®ï¼š/tmp/container.sh</li>
  <li>æ ¹æ®æ¨¡æ¿ç”Ÿæˆè„šæœ¬æ—¶ä¼ å…¥å½“å‰èŠ‚ç‚¹æ‰€æœ‰å®¹å™¨çš„ä¿¡æ¯ï¼Œè„šæœ¬ä¸­ä¼šéå†$containerså‚æ•°ï¼Œæ‰§è¡Œæ£€æµ‹ä»»åŠ¡</li>
</ul>

<p>replaceDockerDaemonCmdline</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>func (b *Bench) replaceDockerDaemonCmdline(srcPath, dstPath string, containers []string) error {
    dat, err := ioutil.ReadFile(srcPath)
    if err != nil {
        return err
    }
    f, err := os.Create(dstPath)
    if err != nil {
        return err
    }
    defer f.Close()

    //containers only apply to container.sh, no effect to host.sh, because no &lt;&lt;&lt;Containers&gt;&gt;&gt; in it
    var containerLines string
    if len(containers) &gt; 0 {
        containerLines = "containers=\"\n" + strings.Join(containers, "\n") + "\"\n"
    } else {
        containerLines = "containers=\"\"\n"
    }
    r := DockerReplaceOpts{
        Replace_docker_daemon_opts: strings.Join(b.daemonOpts, " "),
        Replace_container_list:     containerLines,
    }
    t := template.New("bench")
    t.Delims("&lt;&lt;&lt;", "&gt;&gt;&gt;")
    t.Parse(string(dat))

    if err = t.Execute(f, r); err != nil {
        log.WithFields(log.Fields{"error": err}).Error("Executing template error")
        return err
    }
    return nil
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ç”Ÿæˆç©cisæ£€æµ‹è„šæœ¬åï¼Œä¼šè°ƒç”¨nstoolå‘½ä»¤åœ¨hostä¸Šæ‰§è¡Œæ£€æµ‹å‘½ä»¤ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>nstools run -f host.sh -m  /proc/1/ns/mnt -n /proc/1/ns/net
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>è¿™é‡Œå› ä¸ºè„šæœ¬ä¼šéå†èŠ‚ç‚¹ä¸Šæ‰€æœ‰å®¹å™¨ï¼Œé€šè¿‡dockerå‘½ä»¤æ‰§è¡Œæ£€æµ‹æ“ä½œï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦åœ¨å®¹å™¨å†…éƒ¨æ‰§è¡Œï¼Œæ‰€ä»¥ä¹Ÿä¸ä¸€å®šä½¿ç”¨nstoolå·¥å…·ï¼Œå¯ä»¥ç›´æ¥æ‰§è¡Œshellè„šæœ¬</p>
</blockquote>

<p>åˆ°äº†è¿™é‡Œå·²ç»å®Œæˆäº†æŸä¸ªèŠ‚ç‚¹ä¸Šå®¹å™¨çš„åˆè§„æ€§æ£€æµ‹ä»»åŠ¡ï¼Œæˆ‘ä»¬çœ‹çœ‹æ‰§è¡Œè¿”å›çš„ä¿¡æ¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>...
[WARN] 4.1 - Ensure that a user for the container has been created (Automated)
[WARN]      * Running as root: k8s_busybox_busybox-hujin_default_7191a3da-4c51-467a-a004-db178d79e92a_1158

[WARN] 5.1 - Ensure that, if applicable, an AppArmor Profile is enabled (Automated)
[WARN]      * No AppArmorProfile Found: k8s_busybox_busybox-hujin_default_7191a3da-4c51-467a-a004-db178d79e92a_1158
[PASS] 5.2 - Ensure that, if applicable, SELinux security options are set (Automated)
[PASS] 5.3 - Ensure that Linux kernel capabilities are restricted within containers (Automated)
[PASS] 5.4 - Ensure that privileged containers are not used (Automated)
[PASS] 5.5 - Ensure sensitive host system directories are not mounted on containers (Automated)
[PASS] 5.6 - Ensure sshd is not run within containers (Automated)
[PASS] 5.7 - Ensure privileged ports are not mapped within containers (Automated)
[PASS] 5.8 - Ensure that only needed ports are open on the container (Manual)
[PASS] 5.9 - Ensure that the host's network namespace is not shared (Automated)
...
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>å®¹å™¨çš„åˆè§„æ€§æ£€æµ‹åŠŸèƒ½ï¼Œneuvectoræ˜¯é›†æˆäº†docker-bench-securityé¡¹ç›®ï¼Œå°†è¯¥é¡¹ç›®çš„æ£€æµ‹è„šæœ¬æ•´ç†æˆäº†ä¸€ä¸ªcontainer.tmplæ¨¡æ¿</p>
</blockquote>

<p>åé¢ä¼šå°†æ‰§è¡Œç»“æœè¿›è¡Œæ ¼å¼åŒ–å¹¶ä¿å­˜åˆ°æ•°æ®åº“ï¼Œä»£ç æµç¨‹å°±è®²äº†</p>

<p>è¿™é‡Œè¿˜éœ€è¦ç¨å¾®æä¸€ä¸‹æ³•è§„å’Œcisçš„å…³ç³»ï¼Œæˆ‘ä»¬åœ¨è·å–åˆè§„æ€§æ£€æµ‹ç»“æœçš„æ—¶å€™ï¼ŒhandlerDockerBench - getCISReportFromCluster - _getCISReportFromCluster - 
bench2REST - GetComplianceMetaæ–¹æ³•ä¼šå°†åˆè§„é¡¹æ·»åŠ æ³•è§„å¯¹åº”çš„tagæ ‡è¯†ï¼Œæ–¹ä¾¿è¿›è¡Œè¿‡æ»¤</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>func GetComplianceMeta() ([]api.RESTBenchMeta, map[string]api.RESTBenchMeta) {
    if complianceMetas == nil || complianceMetaMap == nil {
        ...
        for _, item := range docker_image_cis_items {
            all = append(all, api.RESTBenchMeta{RESTBenchCheck: item})
        }

        for i, _ := range all {
            item := &amp;all[i]
            item.Tags = make([]string, 0)
            if compliancePCI.Contains(item.TestNum) {
                item.Tags = append(item.Tags, api.ComplianceTemplatePCI)
            }
            if complianceGDPR.Contains(item.TestNum) {
                item.Tags = append(item.Tags, api.ComplianceTemplateGDPR)
            }
            if complianceHIPAA.Contains(item.TestNum) {
                item.Tags = append(item.Tags, api.ComplianceTemplateHIPAA)
            }
            if complianceNIST.Contains(item.TestNum) {
                item.Tags = append(item.Tags, api.ComplianceTemplateNIST)
            }
            ...
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ”¯æŒçš„æ³•è§„åŒ…æ‹¬ï¼š</p>
<ul>
  <li>PCI</li>
  <li>GDPR</li>
  <li>HIPAA</li>
  <li>NIST</li>
</ul>

<h2 id="æ€»ç»“">æ€»ç»“</h2>
<p>ä»ä¸Šé¢çš„ä»£ç åˆ†æï¼Œæˆ‘ä»¬çœ‹åˆ°neuvectoræ”¯æŒå¯¹host/container/kuberneteså¹³å°çš„åˆè§„æ€§æ£€æµ‹ï¼ŒåŒæ—¶æ”¯æŒä¸€äº›å¸¸è§çš„æ³•è§„ï¼Œå¯ä»¥è¾“å‡ºéå¸¸æ¸…æ™°çš„æ ¼å¼åŒ–ç»“æœå¹¶æä¾›ä¸‹è½½ï¼›
ä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥å‘ç°ä¸€äº›ä¸è¶³çš„åœ°æ–¹ï¼ŒåŒ…æ‹¬ä¸æ”¯æŒå…¶ä»–runtimeã€ä¸æ”¯æŒå›½å†…çš„æ³•è§„ç­‰é—®é¢˜</p>
:ET